<?php

// castor version: v0.22.0
// This file has been generated by castor. Do not edit it manually.
// It helps IDEs to provide better autocompletion and analysis.
// You can safely ignore this file in your VCS.
// ".castor.stub.php" by default is in the same location of "castor.php".
// You can also move this file at the root of your project or to ".castor/.castor.stub.php".

namespace Castor\Attribute {
    #[\Attribute(\Attribute::TARGET_PARAMETER)]
    class AsArgument extends \Castor\Attribute\AsCommandArgument
    {
        /**
         * @param array<string> $suggestedValues
         * @param array<string>|callable(\Symfony\Component\Console\Completion\CompletionInput): array<string> $autocomplete
         */
        public function __construct(
            ?string $name = null,
            public readonly string $description = '',
            /** @deprecated since Castor 0.18, use "autocomplete" property instead */
            public readonly array $suggestedValues = [],
            public readonly mixed $autocomplete = null
        )
        {
        }
    }
    abstract class AsCommandArgument
    {
        public function __construct(public readonly ?string $name = null)
        {
        }
    }
    #[\Attribute(\Attribute::TARGET_FUNCTION)]
    class AsContext
    {
        public function __construct(public string $name = '', public bool $default = false)
        {
        }
    }
    #[\Attribute(\Attribute::TARGET_FUNCTION)]
    class AsContextGenerator
    {
    }
    #[\Attribute(\Attribute::TARGET_FUNCTION | \Attribute::IS_REPEATABLE)]
    class AsListener
    {
        public function __construct(public readonly string $event, public readonly int $priority = 0)
        {
        }
    }
    #[\Attribute(\Attribute::TARGET_PARAMETER)]
    class AsOption extends \Castor\Attribute\AsCommandArgument
    {
        /**
         * @param string|array<string>|null $shortcut
         * @param array<string> $suggestedValues
         * @param array<string>|callable(\Symfony\Component\Console\Completion\CompletionInput): array<string> $autocomplete
         */
        public function __construct(
            ?string $name = null,
            public readonly string|array|null $shortcut = null,
            public readonly ?int $mode = null,
            public readonly string $description = '',
            /** @deprecated since Castor 0.18, use "autocomplete" property instead */
            public readonly array $suggestedValues = [],
            public readonly mixed $autocomplete = null
        )
        {
        }
    }
    #[\Attribute(\Attribute::TARGET_PARAMETER)]
    class AsPathArgument extends \Castor\Attribute\AsArgument
    {
        public function __construct(?string $name = null, string $description = '')
        {
        }
    }
    #[\Attribute(\Attribute::TARGET_PARAMETER)]
    class AsPathOption extends \Castor\Attribute\AsOption
    {
        /**
         * @param string|array<string>|null $shortcut
         */
        public function __construct(?string $name = null, string|array|null $shortcut = null, ?int $mode = null, string $description = '')
        {
        }
    }
    #[\Attribute(\Attribute::TARGET_PARAMETER)]
    class AsRawTokens
    {
    }
    #[\Attribute(\Attribute::TARGET_CLASS)]
    class AsSymfonyTask
    {
        /**
         * @param string[] $console How to start the Symfony application
         */
        public function __construct(public ?string $name = null, public ?string $originalName = null, public readonly array $console = [\PHP_BINARY, 'bin/console'])
        {
        }
    }
    #[\Attribute(\Attribute::TARGET_FUNCTION)]
    class AsTask
    {
        /**
         * @param array<string> $aliases
         * @param array<int, callable(int): (int|false)> $onSignals
         */
        public function __construct(public string $name = '', public ?string $namespace = null, public string $description = '', public array $aliases = [], public array $onSignals = [], public string|bool $enabled = true, public bool $ignoreValidationErrors = false, public bool $default = false)
        {
        }
    }
}
namespace Castor\CommandBuilder {
    interface CommandBuilderInterface
    {
        /**
         * @return string|array<string|\Stringable|int>
         */
        public function getCommand(): array|string;
    }
    interface ContextUpdaterInterface
    {
        public function updateContext(\Castor\Context $context): \Castor\Context;
    }
}
namespace Castor\Console {
    /** @internal */
    class Application extends \Symfony\Component\Console\Application
    {
        public const NAME = 'castor';
        public const VERSION = 'v0.22.0';
        public function __construct(private readonly \Symfony\Component\DependencyInjection\ContainerBuilder $containerBuilder, private readonly \Castor\Kernel $kernel, #[\Symfony\Component\DependencyInjection\Attribute\Autowire(lazy: true)] private readonly \Symfony\Component\Console\Style\SymfonyStyle $io, #[\Symfony\Component\DependencyInjection\Attribute\Autowire(lazy: true)] private readonly \Castor\Runner\ProcessRunner $processRunner, #[\Symfony\Component\DependencyInjection\Attribute\Autowire('%test%')] public readonly bool $test)
        {
        }
        /**
         * @return ($allowNull is true ? ?\Symfony\Component\Console\Command\Command : \Symfony\Component\Console\Command\Command)
         */
        public function getCommand(bool $allowNull = false): ?\Symfony\Component\Console\Command\Command
        {
        }
        public function doRun(\Symfony\Component\Console\Input\InputInterface $input, \Symfony\Component\Console\Output\OutputInterface $output): int
        {
        }
        public function getHelp(): string
        {
        }
        public function renderThrowable(\Throwable $e, \Symfony\Component\Console\Output\OutputInterface $output): void
        {
        }
        protected function doRunCommand(\Symfony\Component\Console\Command\Command $command, \Symfony\Component\Console\Input\InputInterface $input, \Symfony\Component\Console\Output\OutputInterface $output): int
        {
        }
        protected function getDefaultInputDefinition(): \Symfony\Component\Console\Input\InputDefinition
        {
        }
    }
}
namespace Castor\Console\Command {
    /** @internal */
    #[\Symfony\Component\DependencyInjection\Attribute\Exclude]
    class TaskCommand extends \Symfony\Component\Console\Command\Command implements \Symfony\Component\Console\Command\SignalableCommandInterface
    {
        use \Castor\Console\Input\GetRawTokenTrait;
        public function __construct(private readonly \Castor\Descriptor\TaskDescriptor $taskDescriptor, private readonly \Castor\ExpressionLanguage $expressionLanguage, private readonly \Symfony\Component\EventDispatcher\EventDispatcherInterface $eventDispatcher, private readonly \Castor\ContextRegistry $contextRegistry, private readonly \Castor\Helper\Slugger $slugger, private readonly \Symfony\Component\Filesystem\Filesystem $fs)
        {
        }
        /**
         * @return array<int>
         */
        public function getSubscribedSignals(): array
        {
        }
        public function handleSignal(int $signal, int|false $previousExitCode = 0): int|false
        {
        }
        public function isEnabled(): bool
        {
        }
        protected function configure(): void
        {
        }
        protected function execute(\Symfony\Component\Console\Input\InputInterface $input, \Symfony\Component\Console\Output\OutputInterface $output): int
        {
        }
    }
}
namespace Castor\Console\Input {
    /** @internal */
    trait GetRawTokenTrait
    {
    }
}
namespace Castor\Console\Output {
    class SectionDetails
    {
        public function __construct(public \Symfony\Component\Console\Output\ConsoleSectionOutput $section, public \Symfony\Component\Console\Output\ConsoleSectionOutput $progressBarSection, public float $start, public int $index)
        {
        }
    }
    enum VerbosityLevel : int
    {
        case NOT_CONFIGURED = -1;
        case QUIET = 0;
        case NORMAL = 1;
        case VERBOSE = 2;
        case VERY_VERBOSE = 3;
        case DEBUG = 4;
        public static function fromSymfonyOutput(\Symfony\Component\Console\Output\OutputInterface $output): self
        {
        }
        public function isNotConfigured(): bool
        {
        }
        public function isQuiet(): bool
        {
        }
        public function isVerbose(): bool
        {
        }
        public function isVeryVerbose(): bool
        {
        }
        public function isDebug(): bool
        {
        }
    }
}
namespace Castor {
    #[\Symfony\Component\DependencyInjection\Attribute\Exclude]
    class Context implements \ArrayAccess
    {
        public readonly string $workingDirectory;
        /**
         * @phpstan-param ContextData $data The input parameter accepts an array or an Object
         *
         * @param array<string, string|\Stringable|int> $environment A list of environment variables to add to the task
         * @param string[] $verboseArguments A list of arguments to pass to the command to enable verbose output
         */
        public function __construct(public readonly array $data = [], public readonly array $environment = [], ?string $workingDirectory = null, public readonly bool $tty = false, public readonly bool $pty = true, public readonly ?float $timeout = null, public readonly bool $quiet = false, public readonly bool $allowFailure = false, public readonly ?bool $notify = null, public readonly \Castor\Console\Output\VerbosityLevel|\Castor\VerbosityLevel $verbosityLevel = \Castor\Console\Output\VerbosityLevel::NOT_CONFIGURED, public readonly string $name = '', public readonly string $notificationTitle = '', public readonly array $verboseArguments = [])
        {
        }
        public function __debugInfo()
        {
        }
        /**
         * @param array<int|string, mixed> $data
         *
         * @throws \Exception
         */
        public function withData(array $data, bool $keepExisting = true, bool $recursive = true): self
        {
        }
        /** @param array<string, string|\Stringable|int> $environment */
        public function withEnvironment(array $environment, bool $keepExisting = true): self
        {
        }
        public function withPath(string $path): self
        {
        }
        public function withWorkingDirectory(string $workingDirectory): self
        {
        }
        public function withTty(bool $tty = true): self
        {
        }
        public function withPty(bool $pty = true): self
        {
        }
        public function withTimeout(?float $timeout): self
        {
        }
        public function withQuiet(bool $quiet = true): self
        {
        }
        public function withAllowFailure(bool $allowFailure = true): self
        {
        }
        public function withNotify(?bool $notify = true): self
        {
        }
        public function withVerbosityLevel(\Castor\Console\Output\VerbosityLevel|\Castor\VerbosityLevel $verbosityLevel): self
        {
        }
        public function withName(string $name): self
        {
        }
        public function withNotificationTitle(string $notificationTitle): self
        {
        }
        /** @param string[] $arguments */
        public function withVerboseArguments(array $arguments = []): self
        {
        }
        public function toInteractive(): self
        {
        }
        public function offsetExists(mixed $offset): bool
        {
        }
        public function offsetGet(mixed $offset): mixed
        {
        }
        public function offsetSet(mixed $offset, mixed $value): void
        {
        }
        public function offsetUnset(mixed $offset): void
        {
        }
    }
    #[\Symfony\Component\DependencyInjection\Attribute\AsDecorator(\Symfony\Component\EventDispatcher\EventDispatcherInterface::class)]
    class EventDispatcher implements \Symfony\Component\EventDispatcher\EventDispatcherInterface
    {
        public function __construct(private \Symfony\Component\EventDispatcher\EventDispatcherInterface $eventDispatcher = new \Symfony\Component\EventDispatcher\EventDispatcher(), private \Psr\Log\LoggerInterface $logger = new \Psr\Log\NullLogger())
        {
        }
        public function dispatch(object $event, ?string $eventName = null): object
        {
        }
        /**
         * @param callable $listener
         */
        public function addListener(string $eventName, $listener, int $priority = 0): void
        {
        }
        public function removeListener(string $eventName, callable $listener): void
        {
        }
        public function addSubscriber(\Symfony\Component\EventDispatcher\EventSubscriberInterface $subscriber): void
        {
        }
        public function removeSubscriber(\Symfony\Component\EventDispatcher\EventSubscriberInterface $subscriber): void
        {
        }
        public function getListeners(?string $eventName = null): array
        {
        }
        public function getListenerPriority(string $eventName, callable $listener): ?int
        {
        }
        public function hasListeners(?string $eventName = null): bool
        {
        }
    }
    trigger_deprecation('castor/castor', '0.16', 'The "%s" class is deprecated and will be removed in castor 1.0. Use the "%s::getContainer()" instead.', __CLASS__, \Castor\Console\Application::class);
    #[\Symfony\Component\DependencyInjection\Attribute\Exclude]
    class GlobalHelper
    {
        public static function setApplication(\Castor\Console\Application $application): void
        {
        }
        public static function getApplication(): \Castor\Console\Application
        {
        }
        public static function getContextRegistry(): \Castor\ContextRegistry
        {
        }
        public static function getEventDispatcher(): \Symfony\Component\EventDispatcher\EventDispatcherInterface
        {
        }
        public static function getFilesystem(): \Symfony\Component\Filesystem\Filesystem
        {
        }
        public static function getHttpClient(): \Symfony\Contracts\HttpClient\HttpClientInterface
        {
        }
        public static function getCache(): \Psr\Cache\CacheItemPoolInterface&\Symfony\Contracts\Cache\CacheInterface
        {
        }
        public static function getLogger(): \Psr\Log\LoggerInterface
        {
        }
        public static function getInput(): \Symfony\Component\Console\Input\InputInterface
        {
        }
        public static function getSectionOutput(): \Castor\Console\Output\SectionOutput
        {
        }
        public static function getOutput(): \Symfony\Component\Console\Output\OutputInterface
        {
        }
        public static function getSymfonyStyle(): \Symfony\Component\Console\Style\SymfonyStyle
        {
        }
        /**
         * @return ($allowNull is true ? ?\Symfony\Component\Console\Command\Command : \Symfony\Component\Console\Command\Command)
         */
        public static function getCommand(bool $allowNull = false): ?\Symfony\Component\Console\Command\Command
        {
        }
        public static function getContext(?string $name = null): \Castor\Context
        {
        }
        public static function getVariable(string $key, mixed $default = null): mixed
        {
        }
    }
    trigger_deprecation('castor', '0.15', 'The "%s" class is deprecated, use "%s" instead.', \Castor\HasherHelper::class, \Castor\Helper\HasherHelper::class);
    /**
     * @deprecated since castor/castor 0.15, use Castor\Helper\HasherHelper instead.
     */
    #[\Symfony\Component\DependencyInjection\Attribute\Exclude]
    class HasherHelper extends \Castor\Helper\HasherHelper
    {
    }
    trigger_deprecation('castor', '0.15', 'The "%s" class is deprecated, use "%s" instead.', \Castor\PathHelper::class, \Castor\Helper\PathHelper::class);
    /**
     * @deprecated since castor/castor 0.15, use Castor\Helper\PathHelper instead.
     */
    #[\Symfony\Component\DependencyInjection\Attribute\Exclude]
    class PathHelper extends \Castor\Helper\PathHelper
    {
    }
    trigger_deprecation('castor', '0.15.0', 'The "%s" class is deprecated, use "%s" instead.', \Castor\TaskDescriptorCollection::class, \Castor\Descriptor\TaskDescriptorCollection::class);
    /**
     * @deprecated since Castor 0.15.0, use Castor\Descriptor\TaskDescriptorCollection instead
     */
    #[\Symfony\Component\DependencyInjection\Attribute\Exclude]
    class TaskDescriptorCollection extends \Castor\Descriptor\TaskDescriptorCollection
    {
    }
    trigger_deprecation('castor/console', '0.15', 'The "%s" enum is deprecated and will be removed in 1.0. Use "%s" instead.', \Castor\VerbosityLevel::class, \Castor\Console\Output\VerbosityLevel::class);
    /**
     * @deprecated since castor/console 0.15, to be removed in 1.0. Use \Castor\Console\Output\VerbosityLevel instead.
     */
    enum VerbosityLevel : int
    {
        case NOT_CONFIGURED = -1;
        case QUIET = 0;
        case NORMAL = 1;
        case VERBOSE = 2;
        case VERY_VERBOSE = 3;
        case DEBUG = 4;
        public static function fromSymfonyOutput(\Symfony\Component\Console\Output\OutputInterface $output): self
        {
        }
        public function isNotConfigured(): bool
        {
        }
        public function isQuiet(): bool
        {
        }
        public function isVerbose(): bool
        {
        }
        public function isVeryVerbose(): bool
        {
        }
        public function isDebug(): bool
        {
        }
    }
    /**
     * @return array<mixed>
     */
    function parallel(callable ...$callbacks): array
    {
    }
    /**
     * @param string|array<string|\Stringable|int>|\Castor\CommandBuilder\CommandBuilderInterface $command
     * @param array<string, string|\Stringable|int>|null $environment
     * @param callable(string, string, \Symfony\Component\Process\Process): void|null $callback
     */
    function run(string|array|\Castor\CommandBuilder\CommandBuilderInterface $command, ?array $environment = null, ?string $workingDirectory = null, ?bool $tty = null, ?bool $pty = null, ?float $timeout = null, ?bool $quiet = null, ?bool $allowFailure = null, ?bool $notify = null, ?callable $callback = null, ?\Castor\Context $context = null, ?string $path = null): \Symfony\Component\Process\Process
    {
    }
    /**
     * @param string|array<string|\Stringable|int> $command
     * @param array<string, string|\Stringable|int>|null $environment
     */
    function capture(string|array $command, ?array $environment = null, ?string $workingDirectory = null, ?float $timeout = null, ?bool $allowFailure = null, ?string $onFailure = null, ?\Castor\Context $context = null, ?string $path = null): string
    {
    }
    /**
     * @param string|array<string|\Stringable|int> $command
     * @param array<string, string|\Stringable|int>|null $environment
     */
    function exit_code(string|array $command, ?array $environment = null, ?string $workingDirectory = null, ?float $timeout = null, ?bool $quiet = null, ?\Castor\Context $context = null, ?string $path = null): int
    {
    }
    /**
     * @param callable(): bool $check
     */
    function check(string $title, string $failureMessage, callable $check): void
    {
    }
    /**
     * @deprecated Since castor/castor 0.8. Use Castor\exit_code() instead
     */
    function get_exit_code(...$args): int
    {
    }
    /**
     * @param array{port?: int, path_private_key?: string, jump_host?: string, multiplexing_control_path?: string, multiplexing_control_persist?: string, enable_strict_check?: bool, password_authentication?: bool} $sshOptions
     */
    function ssh_run(string $command, string $host, ?string $user = null, array $sshOptions = [], ?string $path = null, ?bool $quiet = null, ?bool $allowFailure = null, ?bool $notify = null, ?float $timeout = null, ?callable $callback = null): \Symfony\Component\Process\Process
    {
    }
    /**
     * @deprecated Since castor/castor 0.10. Use Castor\ssh_run() instead
     */
    function ssh(...$args): \Symfony\Component\Process\Process
    {
    }
    /**
     * @param array{port?: int, path_private_key?: string, jump_host?: string, multiplexing_control_path?: string, multiplexing_control_persist?: string, enable_strict_check?: bool, password_authentication?: bool} $sshOptions
     */
    function ssh_upload(string $sourcePath, string $destinationPath, string $host, ?string $user = null, array $sshOptions = [], ?bool $quiet = null, ?bool $allowFailure = null, ?bool $notify = null, ?float $timeout = null): \Symfony\Component\Process\Process
    {
    }
    /**
     * @param array{port?: int, path_private_key?: string, jump_host?: string, multiplexing_control_path?: string, multiplexing_control_persist?: string, enable_strict_check?: bool, password_authentication?: bool} $sshOptions
     */
    function ssh_download(string $sourcePath, string $destinationPath, string $host, ?string $user = null, array $sshOptions = [], ?bool $quiet = null, ?bool $allowFailure = null, ?bool $notify = null, ?float $timeout = null): \Symfony\Component\Process\Process
    {
    }
    function notify(string $message, ?string $title = null): void
    {
    }
    /**
     * @param string|non-empty-array<string> $path
     * @param callable(string, string): (false|void|null) $function
     */
    function watch(string|array $path, callable $function, ?\Castor\Context $context = null): void
    {
    }
    /**
     * @param array<string, mixed> $context
     *
     * @phpstan-param \Monolog\Level|\Psr\Log\LogLevel::* $level
     */
    function log(string|\Stringable $message, mixed $level = 'info', array $context = []): void
    {
    }
    function logger(): \Psr\Log\LoggerInterface
    {
    }
    function app(): \Castor\Console\Application
    {
    }
    /**
     * @deprecated Since castor/castor 0.8. Use Castor\app() instead
     */
    function get_application(): \Castor\Console\Application
    {
    }
    function input(): \Symfony\Component\Console\Input\InputInterface
    {
    }
    /**
     * @deprecated Since castor/castor 0.8. Use Castor\input() instead
     */
    function get_input(): \Symfony\Component\Console\Input\InputInterface
    {
    }
    function output(): \Symfony\Component\Console\Output\OutputInterface
    {
    }
    /**
     * @deprecated Since castor/castor 0.8. Use Castor\output() instead
     */
    function get_output(): \Symfony\Component\Console\Output\OutputInterface
    {
    }
    function io(): \Symfony\Component\Console\Style\SymfonyStyle
    {
    }
    /**
     * @deprecated Since castor/castor 0.13. Use "Castor\Attributes\AsContextGenerator()" instead.
     */
    function add_context(string $name, \Closure $callable, bool $default = false): void
    {
    }
    function context(?string $name = null): \Castor\Context
    {
    }
    /**
     * @deprecated Since castor/castor 0.8. Use Castor\context() instead
     */
    function get_context(): \Castor\Context
    {
    }
    /**
     * @template TKey of key-of<ContextData>
     * @template TDefault
     *
     * @param TKey|string $key
     * @param TDefault $default
     *
     * @phpstan-return ($key is TKey ? ContextData[TKey] : TDefault)
     */
    function variable(string $key, mixed $default = null): mixed
    {
    }
    /**
     * @return ($allowNull is true ? ?\Symfony\Component\Console\Command\Command : \Symfony\Component\Console\Command\Command)
     */
    function task(bool $allowNull = false): ?\Symfony\Component\Console\Command\Command
    {
    }
    /**
     * @deprecated Since castor/castor 0.8. Use Castor\task() instead
     */
    function get_command(): \Symfony\Component\Console\Command\Command
    {
    }
    function fs(): \Symfony\Component\Filesystem\Filesystem
    {
    }
    function finder(): \Symfony\Component\Finder\Finder
    {
    }
    /**
     * @param string $key The key of the item to retrieve from the cache
     * @param callable(\Psr\Cache\CacheItemInterface, bool): T|callable(\Symfony\Contracts\Cache\ItemInterface, bool): T|\Symfony\Contracts\Cache\CallbackInterface<T> $or Use this callback to compute the value
     *
     * @return T
     *
     * @see CacheInterface::get()
     *
     * @template T
     */
    function cache(string $key, callable $or): mixed
    {
    }
    function get_cache(): \Psr\Cache\CacheItemPoolInterface&\Symfony\Contracts\Cache\CacheInterface
    {
    }
    /**
     * @deprecated Since castor/castor 0.16. Use Castor\http_request() instead
     */
    function request(...$args): \Symfony\Contracts\HttpClient\ResponseInterface
    {
    }
    /**
     * @param array<string, mixed> $options default values at {@see HttpClientInterface::OPTIONS_DEFAULTS}
     */
    function http_request(string $method, string $url, array $options = []): \Symfony\Contracts\HttpClient\ResponseInterface
    {
    }
    /**
     * @param array<string, mixed> $options default values at {@see HttpClientInterface::OPTIONS_DEFAULTS}
     */
    function http_download(string $url, ?string $filePath = null, string $method = 'GET', array $options = [], bool $stream = true): \Symfony\Contracts\HttpClient\ResponseInterface
    {
    }
    function http_client(): \Symfony\Contracts\HttpClient\HttpClientInterface
    {
    }
    /**
     * @param ?array{url?: string, type?: git|svn, reference?: string} $source
     */
    function import(string $path, ?string $file = null, ?string $version = null, ?string $vcs = null, ?array $source = null): void
    {
    }
    function mount(string $path, ?string $namespacePrefix = null): void
    {
    }
    /**
     * @return array<string, mixed>
     */
    function load_dot_env(?string $path = null): array
    {
    }
    /**
     * @template T
     *
     * @param callable(\Castor\Context): T $callback
     * @param array<string, string|\Stringable|int>|null $data
     * @param array<string, string|\Stringable|int>|null $environment
     */
    function with(callable $callback, ?array $data = null, ?array $environment = null, ?string $workingDirectory = null, ?bool $tty = null, ?bool $pty = null, ?float $timeout = null, ?bool $quiet = null, ?bool $allowFailure = null, ?bool $notify = null, \Castor\Context|string|null $context = null, ?string $path = null): mixed
    {
    }
    /**
     * @see https://www.php.net/manual/en/function.hash-algos.php
     */
    function hasher(string $algo = 'xxh128'): \Castor\Helper\HasherHelper
    {
    }
    function fingerprint_exists(string $id, ?string $fingerprint = null, bool $global = false): bool
    {
    }
    function fingerprint_save(string $id, ?string $fingerprint = null, bool $global = false): void
    {
    }
    /**
     * @param string $id
     * @param string $fingerprint
     */
    function fingerprint(callable $callback, $id = null, $fingerprint = null, bool $force = false, bool $global = false): bool
    {
    }
    /**
     * @throws \Castor\Exception\WaitFor\TimeoutReachedException
     * @throws \Castor\Exception\WaitFor\ExitedBeforeTimeoutException
     */
    function wait_for(callable $callback, int $timeout = 10, bool $quiet = false, int $intervalMs = 100, string $message = 'Waiting for callback to be available...'): void
    {
    }
    /**
     * @throws \Castor\Exception\WaitFor\TimeoutReachedException
     * @throws \Castor\Exception\WaitFor\ExitedBeforeTimeoutException
     */
    function wait_for_port(int $port, string $host = '127.0.0.1', int $timeout = 10, bool $quiet = false, int $intervalMs = 100, ?string $message = null): void
    {
    }
    /**
     * @throws \Castor\Exception\WaitFor\TimeoutReachedException
     * @throws \Castor\Exception\WaitFor\ExitedBeforeTimeoutException
     */
    function wait_for_url(string $url, int $timeout = 10, bool $quiet = false, int $intervalMs = 100, ?string $message = null): void
    {
    }
    /**
     * @throws \Castor\Exception\WaitFor\TimeoutReachedException
     * @throws \Castor\Exception\WaitFor\ExitedBeforeTimeoutException
     */
    function wait_for_http_status(string $url, int $status = 200, int $timeout = 10, bool $quiet = false, int $intervalMs = 100, ?string $message = null): void
    {
    }
    /**
     * @throws \Castor\Exception\WaitFor\TimeoutReachedException
     * @throws \Castor\Exception\WaitFor\ExitedBeforeTimeoutException
     */
    function wait_for_http_response(string $url, ?callable $responseChecker = null, int $timeout = 10, bool $quiet = false, int $intervalMs = 100, ?string $message = null): void
    {
    }
    /**
     * @throws \Castor\Exception\WaitFor\TimeoutReachedException
     */
    function wait_for_docker_container(string $containerName, int $timeout = 10, bool $quiet = false, int $intervalMs = 100, ?string $message = null, ?callable $containerChecker = null): void
    {
    }
    /**
     * @see Yaml::parse()
     */
    function yaml_parse(string $content, int $flags = 0): mixed
    {
    }
    /**
     * @see Yaml::dump()
     */
    function yaml_dump(mixed $input, int $inline = 2, int $indent = 4, int $flags = 0): string
    {
    }
    function encrypt_with_password(string $content, string $password): string
    {
    }
    function decrypt_with_password(string $content, string $password): string
    {
    }
    function encrypt_file_with_password(string $sourcePath, string $password, ?string $destinationPath = null): void
    {
    }
    function decrypt_file_with_password(string $sourcePath, string $password, ?string $destinationPath = null): void
    {
    }
    function guard_min_version(string $minVersion): void
    {
    }
    function open(string ...$urls): void
    {
    }
    /**
     * @param array<string|\Stringable> $arguments
     */
    function run_phar(string $pharPath, array $arguments = [], ?\Castor\Context $context = null): \Symfony\Component\Process\Process
    {
    }
}
namespace Castor\Descriptor {
    final class DescriptorsCollection
    {
        /**
         * @param list<\Castor\Descriptor\ContextDescriptor> $contextDescriptors
         * @param list<\Castor\Descriptor\ContextGeneratorDescriptor> $contextGeneratorDescriptors
         * @param list<\Castor\Descriptor\ListenerDescriptor> $listenerDescriptors
         * @param list<\Castor\Descriptor\TaskDescriptor> $taskDescriptors
         * @param list<\Castor\Descriptor\SymfonyTaskDescriptor> $symfonyTaskDescriptors
         */
        public function __construct(public readonly array $contextDescriptors, public readonly array $contextGeneratorDescriptors, public readonly array $listenerDescriptors, public readonly array $taskDescriptors, public readonly array $symfonyTaskDescriptors)
        {
        }
    }
    class SymfonyTaskDescriptor
    {
        /**
         * @param mixed[] $definition
         */
        public function __construct(public readonly \Castor\Attribute\AsSymfonyTask $taskAttribute, public readonly \ReflectionClass $function, public readonly array $definition)
        {
        }
    }
    class TaskDescriptor
    {
        public function __construct(public readonly \Castor\Attribute\AsTask $taskAttribute, public readonly \ReflectionFunction $function, public ?string $workingDirectory = null)
        {
        }
    }
    trigger_deprecation('castor', '0.16', 'The "%s" class is deprecated, use "%s" instead.', \Castor\Descriptor\TaskDescriptorCollection::class, \Castor\Descriptor\DescriptorsCollection::class);
    /**
     * @deprecated since Castor 0.16, use DescriptorsCollection instead
     */
    class TaskDescriptorCollection
    {
        /**
         * @param list<\Castor\Descriptor\TaskDescriptor> $taskDescriptors
         * @param list<\Castor\Descriptor\SymfonyTaskDescriptor> $symfonyTaskDescriptors
         */
        public function __construct(public readonly array $taskDescriptors = [], public readonly array $symfonyTaskDescriptors = [])
        {
        }
    }
}
namespace Castor\Event {
    /**
     * @deprecated since Castor 0.16, use FunctionsResolvedEvent instead
     */
    class AfterApplicationInitializationEvent extends \Symfony\Contracts\EventDispatcher\Event
    {
        public function __construct(public readonly \Castor\Console\Application $application, public \Castor\Descriptor\TaskDescriptorCollection $taskDescriptorCollection)
        {
        }
    }
    class AfterBootEvent extends \Symfony\Contracts\EventDispatcher\Event
    {
        public function __construct(public readonly \Castor\Console\Application $application)
        {
        }
    }
    class AfterExecuteTaskEvent extends \Symfony\Contracts\EventDispatcher\Event
    {
        public function __construct(public readonly \Castor\Console\Command\TaskCommand $task, public readonly mixed $result)
        {
        }
    }
    class BeforeExecuteTaskEvent extends \Symfony\Contracts\EventDispatcher\Event
    {
        public function __construct(public readonly \Castor\Console\Command\TaskCommand $task)
        {
        }
    }
    class ContextCreatedEvent
    {
        public function __construct(public readonly string $contextName, public \Castor\Context $context)
        {
        }
    }
    class FunctionsResolvedEvent extends \Symfony\Contracts\EventDispatcher\Event
    {
        /**
         * @param list<\Castor\Descriptor\TaskDescriptor> $taskDescriptors
         * @param list<\Castor\Descriptor\SymfonyTaskDescriptor> $symfonyTaskDescriptors
         */
        public function __construct(public array $taskDescriptors, public array $symfonyTaskDescriptors)
        {
        }
    }
    class ProcessCreatedEvent extends \Symfony\Contracts\EventDispatcher\Event
    {
        public function __construct(public readonly \Symfony\Component\Process\Process $process)
        {
        }
    }
    class ProcessStartEvent extends \Symfony\Contracts\EventDispatcher\Event
    {
        public function __construct(public readonly \Symfony\Component\Process\Process $process)
        {
        }
    }
    class ProcessTerminateEvent extends \Symfony\Contracts\EventDispatcher\Event
    {
        public function __construct(public readonly \Symfony\Component\Process\Process $process)
        {
        }
    }
}
namespace Castor\Exception {
    class CouldNotFindEntrypointException extends \RuntimeException
    {
        public function __construct(string $message = 'Could not find root "castor.php" or ".castor/castor.php" file.', ?\Throwable $previous = null)
        {
        }
    }
    class ExecutableNotFoundException extends \RuntimeException
    {
        public function __construct(readonly string $executableName)
        {
        }
    }
    class FunctionConfigurationException extends \InvalidArgumentException
    {
        public function __construct(string $message, \ReflectionFunction|\ReflectionClass $function, ?\Throwable $e = null)
        {
        }
    }
    class MinimumVersionRequirementNotMetException extends \RuntimeException
    {
        public function __construct(readonly string $requiredVersion, readonly string $currentVersion)
        {
        }
    }
    class ProblemException extends \RuntimeException
    {
        public function __construct(string $message, int $code = 1, ?\Throwable $previous = null)
        {
        }
    }
}
namespace Castor\Exception\WaitFor {
    class DockerContainerStateException extends \RuntimeException
    {
        public function __construct(readonly string $containerName, readonly string $state)
        {
        }
    }
    class ExitedBeforeTimeoutException extends \RuntimeException
    {
        public function __construct(string $message = 'Callback check returned null, exiting before timeout.')
        {
        }
    }
    class TimeoutReachedException extends \Exception
    {
        public function __construct(int $timeout)
        {
        }
    }
}
namespace Castor\Factory {
    class TaskCommandFactory
    {
        public function __construct(private readonly \Castor\ExpressionLanguage $expressionLanguage, private readonly \Symfony\Component\EventDispatcher\EventDispatcherInterface $eventDispatcher, private readonly \Castor\ContextRegistry $contextRegistry, private readonly \Castor\Helper\Slugger $slugger, private readonly \Symfony\Component\Filesystem\Filesystem $fs)
        {
        }
        public function createTask(\Castor\Descriptor\TaskDescriptor $taskDescriptor): \Castor\Console\Command\TaskCommand
        {
        }
    }
}
namespace Castor\Fingerprint {
    enum FileHashStrategy
    {
        case Content;
        case MTimes;
    }
}
namespace Castor\Helper {
    /** @final */
    #[\Symfony\Component\DependencyInjection\Attribute\Exclude]
    class HasherHelper
    {
        /**
         * @see https://www.php.net/manual/en/function.hash-algos.php
         */
        public function __construct(private readonly \Symfony\Component\Console\Command\Command $command, private readonly \Symfony\Component\Console\Input\InputInterface $input, private readonly \Psr\Log\LoggerInterface $logger = new \Psr\Log\NullLogger(), string $algo = 'xxh128')
        {
        }
        public function write(string $value): self
        {
        }
        public function writeFile(string $path, \Castor\Fingerprint\FileHashStrategy $strategy = \Castor\Fingerprint\FileHashStrategy::MTimes): self
        {
        }
        public function writeWithFinder(\Symfony\Component\Finder\Finder $finder, \Castor\Fingerprint\FileHashStrategy $strategy = \Castor\Fingerprint\FileHashStrategy::MTimes): self
        {
        }
        public function writeGlob(string $pattern, \Castor\Fingerprint\FileHashStrategy $strategy = \Castor\Fingerprint\FileHashStrategy::MTimes): self
        {
        }
        public function writeTaskName(): self
        {
        }
        public function writeTaskArgs(string ...$args): self
        {
        }
        public function writeTask(string ...$args): self
        {
        }
        public function finish(): string
        {
        }
    }
    /** @final */
    #[\Symfony\Component\DependencyInjection\Attribute\Exclude]
    class PathHelper
    {
        public static function getCastorVendorDir(): string
        {
        }
        public static function getRoot(): string
        {
        }
        public static function realpath(string $path): string
        {
        }
        public static function makeRelative(string $path): string
        {
        }
    }
}
namespace Castor\Import\Exception {
    class ComposerError extends \Castor\Import\Exception\ImportError
    {
    }
    class ImportError extends \RuntimeException
    {
    }
    class InvalidImportFormat extends \Castor\Import\Exception\ImportError
    {
    }
    class RemoteNotAllowed extends \RuntimeException
    {
    }
}
namespace Psr\Cache {
    interface CacheItemInterface
    {
        /**
        * Returns the key for the current cache item.
        *
        * The key is loaded by the Implementing Library, but should be available to
        the higher level callers when needed.
        *
        * @return string
        *   The key string for this cache item.
        */
        public function getKey(): string;
        /**
        * Retrieves the value of the item from the cache associated with this object's key.
        *
        * The value returned must be identical to the value originally stored by set().
        *
        * If isHit() returns false, this method MUST return null. Note that null
        is a legitimate cached value, so the isHit() method SHOULD be used to
        differentiate between "null value was found" and "no value was found."
        *
        * @return mixed
        *   The value corresponding to this cache item's key, or null if not found.
        */
        public function get(): mixed;
        /**
        * Confirms if the cache item lookup resulted in a cache hit.
        *
        * Note: This method MUST NOT have a race condition between calling isHit()
        and calling get().
        *
        * @return bool
        *   True if the request resulted in a cache hit. False otherwise.
        */
        public function isHit(): bool;
        /**
        * Sets the value represented by this cache item.
        *
        * The $value argument may be any item that can be serialized by PHP,
        although the method of serialization is left up to the Implementing
        Library.
        *
        * @param mixed $value
        *   The serializable value to be stored.
        *
        * @return static
        *   The invoked object.
        */
        public function set(mixed $value): static;
        /**
        * Sets the expiration time for this cache item.
        *
        * @param ?\DateTimeInterface $expiration
        *   The point in time after which the item MUST be considered expired.
          If null is passed explicitly, a default value MAY be used. If none is set,
          the value should be stored permanently or for as long as the
          implementation allows.
        *
        * @return static
        *   The called object.
        */
        public function expiresAt(?\DateTimeInterface $expiration): static;
        /**
        * Sets the expiration time for this cache item.
        *
        * @param int|\DateInterval|null $time
        *   The period of time from the present after which the item MUST be considered
          expired. An integer parameter is understood to be the time in seconds until
          expiration. If null is passed explicitly, a default value MAY be used.
          If none is set, the value should be stored permanently or for as long as the
          implementation allows.
        *
        * @return static
        *   The called object.
        */
        public function expiresAfter(int|\DateInterval|null $time): static;
    }
    interface CacheItemPoolInterface
    {
        /**
        * Returns a Cache Item representing the specified key.
        *
        * This method must always return a CacheItemInterface object, even in case of
        a cache miss. It MUST NOT return null.
        *
        * @param string $key
        *   The key for which to return the corresponding Cache Item.
        *
        * @throws \Psr\Cache\InvalidArgumentException
        *   If the $key string is not a legal value a \Psr\Cache\InvalidArgumentException
          MUST be thrown.
        *
        * @return \Psr\Cache\CacheItemInterface
        *   The corresponding Cache Item.
        */
        public function getItem(string $key): \Psr\Cache\CacheItemInterface;
        /**
        * Returns a traversable set of cache items.
        *
        * @param string[] $keys
        *   An indexed array of keys of items to retrieve.
        *
        * @throws \Psr\Cache\InvalidArgumentException
        *   If any of the keys in $keys are not a legal value a \Psr\Cache\InvalidArgumentException
          MUST be thrown.
        *
        * @return iterable
        *   An iterable collection of Cache Items keyed by the cache keys of
          each item. A Cache item will be returned for each key, even if that
          key is not found. However, if no keys are specified then an empty
          traversable MUST be returned instead.
        */
        public function getItems(array $keys = []): iterable;
        /**
        * Confirms if the cache contains specified cache item.
        *
        * Note: This method MAY avoid retrieving the cached value for performance reasons.
        This could result in a race condition with CacheItemInterface::get(). To avoid
        such situation use CacheItemInterface::isHit() instead.
        *
        * @param string $key
        *   The key for which to check existence.
        *
        * @throws \Psr\Cache\InvalidArgumentException
        *   If the $key string is not a legal value a \Psr\Cache\InvalidArgumentException
          MUST be thrown.
        *
        * @return bool
        *   True if item exists in the cache, false otherwise.
        */
        public function hasItem(string $key): bool;
        /**
         * Deletes all items in the pool.
         *
         * @return bool
         *   True if the pool was successfully cleared. False if there was an error.
         */
        public function clear(): bool;
        /**
        * Removes the item from the pool.
        *
        * @param string $key
        *   The key to delete.
        *
        * @throws \Psr\Cache\InvalidArgumentException
        *   If the $key string is not a legal value a \Psr\Cache\InvalidArgumentException
          MUST be thrown.
        *
        * @return bool
        *   True if the item was successfully removed. False if there was an error.
        */
        public function deleteItem(string $key): bool;
        /**
        * Removes multiple items from the pool.
        *
        * @param string[] $keys
        *   An array of keys that should be removed from the pool.
        *
        * @throws \Psr\Cache\InvalidArgumentException
        *   If any of the keys in $keys are not a legal value a \Psr\Cache\InvalidArgumentException
          MUST be thrown.
        *
        * @return bool
        *   True if the items were successfully removed. False if there was an error.
        */
        public function deleteItems(array $keys): bool;
        /**
         * Persists a cache item immediately.
         *
         * @param \Psr\Cache\CacheItemInterface $item
         *   The cache item to save.
         *
         * @return bool
         *   True if the item was successfully persisted. False if there was an error.
         */
        public function save(\Psr\Cache\CacheItemInterface $item): bool;
        /**
         * Sets a cache item to be persisted later.
         *
         * @param \Psr\Cache\CacheItemInterface $item
         *   The cache item to save.
         *
         * @return bool
         *   False if the item could not be queued or if a commit was attempted and failed. True otherwise.
         */
        public function saveDeferred(\Psr\Cache\CacheItemInterface $item): bool;
        /**
         * Persists any deferred cache items.
         *
         * @return bool
         *   True if all not-yet-saved items were successfully saved or there were none. False otherwise.
         */
        public function commit(): bool;
    }
    interface InvalidArgumentException extends \Psr\Cache\CacheException
    {
    }
    interface CacheException extends \Throwable
    {
    }
}
namespace Psr\Log {
    interface LoggerInterface
    {
        /**
         * System is unusable.
         *
         * @param mixed[] $context
         */
        public function emergency(string|\Stringable $message, array $context = []): void;
        /**
        * Action must be taken immediately.
        *
        * Example: Entire website down, database unavailable, etc. This should
        trigger the SMS alerts and wake you up.
        *
        * @param mixed[] $context
        */
        public function alert(string|\Stringable $message, array $context = []): void;
        /**
         * Critical conditions.
         *
         * Example: Application component unavailable, unexpected exception.
         *
         * @param mixed[] $context
         */
        public function critical(string|\Stringable $message, array $context = []): void;
        /**
        * Runtime errors that do not require immediate action but should typically
        be logged and monitored.
        *
        * @param mixed[] $context
        */
        public function error(string|\Stringable $message, array $context = []): void;
        /**
        * Exceptional occurrences that are not errors.
        *
        * Example: Use of deprecated APIs, poor use of an API, undesirable things
        that are not necessarily wrong.
        *
        * @param mixed[] $context
        */
        public function warning(string|\Stringable $message, array $context = []): void;
        /**
         * Normal but significant events.
         *
         * @param mixed[] $context
         */
        public function notice(string|\Stringable $message, array $context = []): void;
        /**
         * Interesting events.
         *
         * Example: User logs in, SQL logs.
         *
         * @param mixed[] $context
         */
        public function info(string|\Stringable $message, array $context = []): void;
        /**
         * Detailed debug information.
         *
         * @param mixed[] $context
         */
        public function debug(string|\Stringable $message, array $context = []): void;
        /**
         * Logs with an arbitrary level.
         *
         * @param mixed $level
         * @param mixed[] $context
         *
         * @throws \Psr\Log\InvalidArgumentException
         */
        public function log($level, string|\Stringable $message, array $context = []): void;
    }
}
namespace Symfony\Component\Console {
    /**
    * An Application is the container for a collection of commands.
    *
    * It is the main entry point of a Console application.
    *
    * This class is optimized for a standard CLI environment.
    *
    * Usage:
    *
    *     $app = new Application('myapp', '1.0 (stable)');
       $app->add(new SimpleCommand());
       $app->run();
    *
    * @author Fabien Potencier <fabien@symfony.com>
    */
    class Application implements \Symfony\Contracts\Service\ResetInterface
    {
        public function __construct(string $name = 'UNKNOWN', string $version = 'UNKNOWN')
        {
        }
        /**
         * @final
         */
        public function setDispatcher(\Symfony\Contracts\EventDispatcher\EventDispatcherInterface $dispatcher): void
        {
        }
        /**
         * @return void
         */
        public function setCommandLoader(\Symfony\Component\Console\CommandLoader\CommandLoaderInterface $commandLoader)
        {
        }
        public function getSignalRegistry(): \Symfony\Component\Console\SignalRegistry\SignalRegistry
        {
        }
        /**
         * @return void
         */
        public function setSignalsToDispatchEvent(int ...$signalsToDispatchEvent)
        {
        }
        /**
         * Runs the current application.
         *
         * @return int 0 if everything went fine, or an error code
         *
         * @throws \Exception When running fails. Bypass this when {@link setCatchExceptions()}.
         */
        public function run(?\Symfony\Component\Console\Input\InputInterface $input = null, ?\Symfony\Component\Console\Output\OutputInterface $output = null): int
        {
        }
        /**
         * Runs the current application.
         *
         * @return int 0 if everything went fine, or an error code
         */
        public function doRun(\Symfony\Component\Console\Input\InputInterface $input, \Symfony\Component\Console\Output\OutputInterface $output)
        {
        }
        /**
         * @return void
         */
        public function reset()
        {
        }
        /**
         * @return void
         */
        public function setHelperSet(\Symfony\Component\Console\Helper\HelperSet $helperSet)
        {
        }
        public function getHelperSet(): \Symfony\Component\Console\Helper\HelperSet
        {
        }
        /**
         * @return void
         */
        public function setDefinition(\Symfony\Component\Console\Input\InputDefinition $definition)
        {
        }
        public function getDefinition(): \Symfony\Component\Console\Input\InputDefinition
        {
        }
        public function complete(\Symfony\Component\Console\Completion\CompletionInput $input, \Symfony\Component\Console\Completion\CompletionSuggestions $suggestions): void
        {
        }
        public function getHelp(): string
        {
        }
        public function areExceptionsCaught(): bool
        {
        }
        /**
         * Sets whether to catch exceptions or not during commands execution.
         *
         * @return void
         */
        public function setCatchExceptions(bool $boolean)
        {
        }
        public function setCatchErrors(bool $catchErrors = true): void
        {
        }
        public function isAutoExitEnabled(): bool
        {
        }
        /**
         * Sets whether to automatically exit after a command execution or not.
         *
         * @return void
         */
        public function setAutoExit(bool $boolean)
        {
        }
        public function getName(): string
        {
        }
        /**
         * Sets the application name.
         *
         * @return void
         */
        public function setName(string $name)
        {
        }
        public function getVersion(): string
        {
        }
        /**
         * Sets the application version.
         *
         * @return void
         */
        public function setVersion(string $version)
        {
        }
        /**
         * Returns the long version of the application.
         *
         * @return string
         */
        public function getLongVersion()
        {
        }
        public function register(string $name): \Symfony\Component\Console\Command\Command
        {
        }
        /**
         * Adds an array of command objects.
         *
         * If a Command is not enabled it will not be added.
         *
         * @param \Symfony\Component\Console\Command\Command[] $commands An array of commands
         *
         * @return void
         */
        public function addCommands(array $commands)
        {
        }
        /**
        * Adds a command object.
        *
        * If a command with the same name already exists, it will be overridden.
        If the command is not enabled it will not be added.
        *
        * @return \Symfony\Component\Console\Command\Command|null
        */
        public function add(\Symfony\Component\Console\Command\Command $command)
        {
        }
        /**
         * Returns a registered command by name or alias.
         *
         * @return \Symfony\Component\Console\Command\Command
         *
         * @throws \Symfony\Component\Console\Exception\CommandNotFoundException When given command name does not exist
         */
        public function get(string $name)
        {
        }
        public function has(string $name): bool
        {
        }
        /**
         * Returns an array of all unique namespaces used by currently registered commands.
         *
         * It does not return the global namespace which always exists.
         *
         * @return string[]
         */
        public function getNamespaces(): array
        {
        }
        /**
         * Finds a registered namespace by a name or an abbreviation.
         *
         * @throws \Symfony\Component\Console\Exception\NamespaceNotFoundException When namespace is incorrect or ambiguous
         */
        public function findNamespace(string $namespace): string
        {
        }
        /**
        * Finds a command by name or alias.
        *
        * Contrary to get, this command tries to find the best
        match if you give it an abbreviation of a name or alias.
        *
        * @return \Symfony\Component\Console\Command\Command
        *
        * @throws \Symfony\Component\Console\Exception\CommandNotFoundException When command name is incorrect or ambiguous
        */
        public function find(string $name)
        {
        }
        /**
         * Gets the commands (registered in the given namespace if provided).
         *
         * The array keys are the full names and the values the command instances.
         *
         * @return \Symfony\Component\Console\Command\Command[]
         */
        public function all(?string $namespace = null)
        {
        }
        /**
         * Returns an array of possible abbreviations given a set of names.
         *
         * @return string[][]
         */
        public static function getAbbreviations(array $names): array
        {
        }
        public function renderThrowable(\Throwable $e, \Symfony\Component\Console\Output\OutputInterface $output): void
        {
        }
        protected function doRenderThrowable(\Throwable $e, \Symfony\Component\Console\Output\OutputInterface $output): void
        {
        }
        /**
         * Configures the input and output instances based on the user arguments and options.
         *
         * @return void
         */
        protected function configureIO(\Symfony\Component\Console\Input\InputInterface $input, \Symfony\Component\Console\Output\OutputInterface $output)
        {
        }
        /**
        * Runs the current command.
        *
        * If an event dispatcher has been attached to the application,
        events are also dispatched during the life-cycle of the command.
        *
        * @return int 0 if everything went fine, or an error code
        */
        protected function doRunCommand(\Symfony\Component\Console\Command\Command $command, \Symfony\Component\Console\Input\InputInterface $input, \Symfony\Component\Console\Output\OutputInterface $output)
        {
        }
        protected function getCommandName(\Symfony\Component\Console\Input\InputInterface $input): ?string
        {
        }
        protected function getDefaultInputDefinition(): \Symfony\Component\Console\Input\InputDefinition
        {
        }
        /**
         * Gets the default commands that should always be available.
         *
         * @return \Symfony\Component\Console\Command\Command[]
         */
        protected function getDefaultCommands(): array
        {
        }
        protected function getDefaultHelperSet(): \Symfony\Component\Console\Helper\HelperSet
        {
        }
        public function extractNamespace(string $name, ?int $limit = null): string
        {
        }
        /**
         * Sets the default Command name.
         *
         * @return $this
         */
        public function setDefaultCommand(string $commandName, bool $isSingleCommand = false): static
        {
        }
    }
}
namespace Symfony\Component\Console\Command {
    /**
     * Base class for all commands.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class Command
    {
        public const SUCCESS = 0;
        public const FAILURE = 1;
        public const INVALID = 2;
        /**
         * @var string|null The default command name
         *
         * @deprecated since Symfony 6.1, use the AsCommand attribute instead
         */
        protected static $defaultName;
        /**
         * @var string|null The default command description
         *
         * @deprecated since Symfony 6.1, use the AsCommand attribute instead
         */
        protected static $defaultDescription;
        public static function getDefaultName(): ?string
        {
        }
        public static function getDefaultDescription(): ?string
        {
        }
        /**
         * @param string|null $name The name of the command; passing null means it must be set in configure()
         *
         * @throws \Symfony\Component\Console\Exception\LogicException When the command name is empty
         */
        public function __construct(?string $name = null)
        {
        }
        /**
         * Ignores validation errors.
         *
         * This is mainly useful for the help command.
         *
         * @return void
         */
        public function ignoreValidationErrors()
        {
        }
        /**
         * @return void
         */
        public function setApplication(?\Symfony\Component\Console\Application $application = null)
        {
        }
        /**
         * @return void
         */
        public function setHelperSet(\Symfony\Component\Console\Helper\HelperSet $helperSet)
        {
        }
        public function getHelperSet(): ?\Symfony\Component\Console\Helper\HelperSet
        {
        }
        public function getApplication(): ?\Symfony\Component\Console\Application
        {
        }
        /**
        * Checks whether the command is enabled or not in the current environment.
        *
        * Override this to check for x or y and return false if the command cannot
        run properly under the current conditions.
        *
        * @return bool
        */
        public function isEnabled()
        {
        }
        /**
         * Configures the current command.
         *
         * @return void
         */
        protected function configure()
        {
        }
        /**
        * Executes the current command.
        *
        * This method is not abstract because you can use this class
        as a concrete class. In this case, instead of defining the
        execute() method, you set the code to execute by passing
        a Closure to the setCode() method.
        *
        * @return int 0 if everything went fine, or an exit code
        *
        * @throws \Symfony\Component\Console\Exception\LogicException When this abstract method is not implemented
        *
        * @see setCode()
        */
        protected function execute(\Symfony\Component\Console\Input\InputInterface $input, \Symfony\Component\Console\Output\OutputInterface $output)
        {
        }
        /**
        * Interacts with the user.
        *
        * This method is executed before the InputDefinition is validated.
        This means that this is the only place where the command can
        interactively ask for values of missing required arguments.
        *
        * @return void
        */
        protected function interact(\Symfony\Component\Console\Input\InputInterface $input, \Symfony\Component\Console\Output\OutputInterface $output)
        {
        }
        /**
        * Initializes the command after the input has been bound and before the input
        is validated.
        *
        * This is mainly useful when a lot of commands extends one main command
        where some things need to be initialized based on the input arguments and options.
        *
        * @see InputInterface::bind()
        * @see InputInterface::validate()
        *
        * @return void
        */
        protected function initialize(\Symfony\Component\Console\Input\InputInterface $input, \Symfony\Component\Console\Output\OutputInterface $output)
        {
        }
        /**
        * Runs the command.
        *
        * The code to execute is either defined directly with the
        setCode() method or by overriding the execute() method
        in a sub-class.
        *
        * @return int The command exit code
        *
        * @throws \Symfony\Component\Console\Exception\ExceptionInterface When input binding fails. Bypass this by calling {@link ignoreValidationErrors()}.
        *
        * @see setCode()
        * @see execute()
        */
        public function run(\Symfony\Component\Console\Input\InputInterface $input, \Symfony\Component\Console\Output\OutputInterface $output): int
        {
        }
        public function complete(\Symfony\Component\Console\Completion\CompletionInput $input, \Symfony\Component\Console\Completion\CompletionSuggestions $suggestions): void
        {
        }
        /**
        * Sets the code to execute when running this command.
        *
        * If this method is used, it overrides the code defined
        in the execute() method.
        *
        * @param callable $code A callable(InputInterface $input, OutputInterface $output)
        *
        * @return $this
        *
        * @throws \Symfony\Component\Console\Exception\InvalidArgumentException
        *
        * @see execute()
        */
        public function setCode(callable $code): static
        {
        }
        /**
         * Sets an array of argument and option instances.
         *
         * @return $this
         */
        public function setDefinition(array|\Symfony\Component\Console\Input\InputDefinition $definition): static
        {
        }
        public function getDefinition(): \Symfony\Component\Console\Input\InputDefinition
        {
        }
        public function getNativeDefinition(): \Symfony\Component\Console\Input\InputDefinition
        {
        }
        /**
         * Adds an argument.
         *
         * @param $mode The argument mode: InputArgument::REQUIRED or InputArgument::OPTIONAL
         * @param $default The default value (for InputArgument::OPTIONAL mode only)
         * @param array|\Closure(\Symfony\Component\Console\Completion\CompletionInput, \Symfony\Component\Console\Completion\CompletionSuggestions): list<string|\Symfony\Component\Console\Completion\Suggestion> $suggestedValues The values used for input completion
         *
         * @return $this
         *
         * @throws \Symfony\Component\Console\Exception\InvalidArgumentException When argument mode is not valid
         */
        public function addArgument(string $name, ?int $mode = null, string $description = '', mixed $default = null): static
        {
        }
        /**
         * Adds an option.
         *
         * @param $shortcut The shortcuts, can be null, a string of shortcuts delimited by | or an array of shortcuts
         * @param $mode The option mode: One of the InputOption::VALUE_* constants
         * @param $default The default value (must be null for InputOption::VALUE_NONE)
         * @param array|\Closure(\Symfony\Component\Console\Completion\CompletionInput, \Symfony\Component\Console\Completion\CompletionSuggestions): list<string|\Symfony\Component\Console\Completion\Suggestion> $suggestedValues The values used for input completion
         *
         * @return $this
         *
         * @throws \Symfony\Component\Console\Exception\InvalidArgumentException If option mode is invalid or incompatible
         */
        public function addOption(string $name, string|array|null $shortcut = null, ?int $mode = null, string $description = '', mixed $default = null): static
        {
        }
        /**
        * Sets the name of the command.
        *
        * This method can set both the namespace and the name if
        you separate them by a colon (:)
        *
        *     $command->setName('foo:bar');
        *
        * @return $this
        *
        * @throws \Symfony\Component\Console\Exception\InvalidArgumentException When the name is invalid
        */
        public function setName(string $name): static
        {
        }
        /**
        * Sets the process title of the command.
        *
        * This feature should be used only when creating a long process command,
        like a daemon.
        *
        * @return $this
        */
        public function setProcessTitle(string $title): static
        {
        }
        public function getName(): ?string
        {
        }
        /**
         * @param bool $hidden Whether or not the command should be hidden from the list of commands
         *
         * @return $this
         */
        public function setHidden(bool $hidden = true): static
        {
        }
        /**
         * @return bool whether the command should be publicly shown or not
         */
        public function isHidden(): bool
        {
        }
        /**
         * Sets the description for the command.
         *
         * @return $this
         */
        public function setDescription(string $description): static
        {
        }
        public function getDescription(): string
        {
        }
        /**
         * Sets the help for the command.
         *
         * @return $this
         */
        public function setHelp(string $help): static
        {
        }
        public function getHelp(): string
        {
        }
        public function getProcessedHelp(): string
        {
        }
        /**
         * Sets the aliases for the command.
         *
         * @param string[] $aliases An array of aliases for the command
         *
         * @return $this
         *
         * @throws \Symfony\Component\Console\Exception\InvalidArgumentException When an alias is invalid
         */
        public function setAliases(iterable $aliases): static
        {
        }
        public function getAliases(): array
        {
        }
        /**
         * Returns the synopsis for the command.
         *
         * @param bool $short Whether to show the short version of the synopsis (with options folded) or not
         */
        public function getSynopsis(bool $short = false): string
        {
        }
        /**
         * Add a command usage example, it'll be prefixed with the command name.
         *
         * @return $this
         */
        public function addUsage(string $usage): static
        {
        }
        public function getUsages(): array
        {
        }
        /**
         * Gets a helper instance by name.
         *
         * @return \Symfony\Component\Console\Helper\HelperInterface
         *
         * @throws \Symfony\Component\Console\Exception\LogicException if no HelperSet is defined
         * @throws \Symfony\Component\Console\Exception\InvalidArgumentException if the helper is not defined
         */
        public function getHelper(string $name): mixed
        {
        }
    }
}
namespace Symfony\Component\Console\Completion {
    /**
    * An input specialized for shell completion.
    *
    * This input allows unfinished option names or values and exposes what kind of
    completion is expected.
    *
    * @author Wouter de Jong <wouter@wouterj.nl>
    */
    final class CompletionInput extends \Symfony\Component\Console\Input\ArgvInput
    {
        public const TYPE_ARGUMENT_VALUE = 'argument_value';
        public const TYPE_OPTION_VALUE = 'option_value';
        public const TYPE_OPTION_NAME = 'option_name';
        public const TYPE_NONE = 'none';
        public static function fromString(string $inputStr, int $currentIndex): self
        {
        }
        /**
         * Create an input based on an COMP_WORDS token list.
         *
         * @param string[] $tokens the set of split tokens (e.g. COMP_WORDS or argv)
         * @param int $currentIndex the index of the cursor (e.g. COMP_CWORD)
         */
        public static function fromTokens(array $tokens, int $currentIndex): self
        {
        }
        public function bind(\Symfony\Component\Console\Input\InputDefinition $definition): void
        {
        }
        /**
        * Returns the type of completion required.
        *
        * TYPE_ARGUMENT_VALUE when completing the value of an input argument
        TYPE_OPTION_VALUE   when completing the value of an input option
        TYPE_OPTION_NAME    when completing the name of an input option
        TYPE_NONE           when nothing should be completed
        *
        * TYPE_OPTION_NAME and TYPE_NONE are already implemented by the Console component.
        *
        * @return self::TYPE_*
        */
        public function getCompletionType(): string
        {
        }
        /**
         * The name of the input option or argument when completing a value.
         *
         * @return string|null returns null when completing an option name
         */
        public function getCompletionName(): ?string
        {
        }
        public function getCompletionValue(): string
        {
        }
        public function mustSuggestOptionValuesFor(string $optionName): bool
        {
        }
        public function mustSuggestArgumentValuesFor(string $argumentName): bool
        {
        }
        protected function parseToken(string $token, bool $parseOptions): bool
        {
        }
        public function __toString()
        {
        }
    }
}
namespace Symfony\Component\Console\Helper {
    /**
     * The ProgressBar provides helpers to display progress output.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     * @author Chris Jones <leeked@gmail.com>
     */
    final class ProgressBar
    {
        public const FORMAT_VERBOSE = 'verbose';
        public const FORMAT_VERY_VERBOSE = 'very_verbose';
        public const FORMAT_DEBUG = 'debug';
        public const FORMAT_NORMAL = 'normal';
        /**
         * @param int $max Maximum steps (0 if unknown)
         */
        public function __construct(\Symfony\Component\Console\Output\OutputInterface $output, int $max = 0, float $minSecondsBetweenRedraws = 1 / 25)
        {
        }
        /**
         * Sets a placeholder formatter for a given name, globally for all instances of ProgressBar.
         *
         * This method also allow you to override an existing placeholder.
         *
         * @param string $name The placeholder name (including the delimiter char like %)
         * @param callable(\Symfony\Component\Console\Helper\ProgressBar): string $callable A PHP callable
         */
        public static function setPlaceholderFormatterDefinition(string $name, callable $callable): void
        {
        }
        /**
         * Gets the placeholder formatter for a given name.
         *
         * @param string $name The placeholder name (including the delimiter char like %)
         */
        public static function getPlaceholderFormatterDefinition(string $name): ?callable
        {
        }
        /**
         * Sets a placeholder formatter for a given name, for this instance only.
         *
         * @param callable(\Symfony\Component\Console\Helper\ProgressBar): string $callable A PHP callable
         */
        public function setPlaceholderFormatter(string $name, callable $callable): void
        {
        }
        /**
         * Gets the placeholder formatter for a given name.
         *
         * @param string $name The placeholder name (including the delimiter char like %)
         */
        public function getPlaceholderFormatter(string $name): ?callable
        {
        }
        /**
         * Sets a format for a given name.
         *
         * This method also allow you to override an existing format.
         *
         * @param string $name The format name
         * @param string $format A format string
         */
        public static function setFormatDefinition(string $name, string $format): void
        {
        }
        /**
         * Gets the format for a given name.
         *
         * @param string $name The format name
         */
        public static function getFormatDefinition(string $name): ?string
        {
        }
        /**
        * Associates a text with a named placeholder.
        *
        * The text is displayed when the progress bar is rendered but only
        when the corresponding placeholder is part of the custom format line
        (by wrapping the name with %).
        *
        * @param string $message The text to associate with the placeholder
        * @param string $name The name of the placeholder
        */
        public function setMessage(string $message, string $name = 'message'): void
        {
        }
        public function getMessage(string $name = 'message'): ?string
        {
        }
        public function getStartTime(): int
        {
        }
        public function getMaxSteps(): int
        {
        }
        public function getProgress(): int
        {
        }
        public function getProgressPercent(): float
        {
        }
        public function getBarOffset(): float
        {
        }
        public function getEstimated(): float
        {
        }
        public function getRemaining(): float
        {
        }
        public function setBarWidth(int $size): void
        {
        }
        public function getBarWidth(): int
        {
        }
        public function setBarCharacter(string $char): void
        {
        }
        public function getBarCharacter(): string
        {
        }
        public function setEmptyBarCharacter(string $char): void
        {
        }
        public function getEmptyBarCharacter(): string
        {
        }
        public function setProgressCharacter(string $char): void
        {
        }
        public function getProgressCharacter(): string
        {
        }
        public function setFormat(string $format): void
        {
        }
        /**
         * Sets the redraw frequency.
         *
         * @param int|null $freq The frequency in steps
         */
        public function setRedrawFrequency(?int $freq): void
        {
        }
        public function minSecondsBetweenRedraws(float $seconds): void
        {
        }
        public function maxSecondsBetweenRedraws(float $seconds): void
        {
        }
        /**
         * Returns an iterator that will automatically update the progress bar when iterated.
         *
         * @template TKey
         * @template TValue
         *
         * @param iterable<TKey, TValue> $iterable
         * @param int|null $max Number of steps to complete the bar (0 if indeterminate), if null it will be inferred from $iterable
         *
         * @return iterable<TKey, TValue>
         */
        public function iterate(iterable $iterable, ?int $max = null): iterable
        {
        }
        /**
         * Starts the progress output.
         *
         * @param int|null $max Number of steps to complete the bar (0 if indeterminate), null to leave unchanged
         * @param int $startAt The starting point of the bar (useful e.g. when resuming a previously started bar)
         */
        public function start(?int $max = null, int $startAt = 0): void
        {
        }
        /**
         * Advances the progress output X steps.
         *
         * @param int $step Number of steps to advance
         */
        public function advance(int $step = 1): void
        {
        }
        public function setOverwrite(bool $overwrite): void
        {
        }
        public function setProgress(int $step): void
        {
        }
        public function setMaxSteps(int $max): void
        {
        }
        public function finish(): void
        {
        }
        public function display(): void
        {
        }
        public function clear(): void
        {
        }
    }
    /**
     * Marks a row as being a separator.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class TableSeparator extends \Symfony\Component\Console\Helper\TableCell
    {
        public function __construct(array $options = [])
        {
        }
    }
    /**
     * Defines the styles for a Table.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     * @author Саша Стаменковић <umpirsky@gmail.com>
     * @author Dany Maillard <danymaillard93b@gmail.com>
     */
    class TableStyle
    {
        /**
         * Sets padding character, used for cell padding.
         *
         * @return $this
         */
        public function setPaddingChar(string $paddingChar): static
        {
        }
        public function getPaddingChar(): string
        {
        }
        /**
        * Sets horizontal border characters.
        *
        * <code>
        ╔═══════════════╤══════════════════════════╤══════════════════╗
        1 ISBN          2 Title                    │ Author           ║
        ╠═══════════════╪══════════════════════════╪══════════════════╣
        ║ 99921-58-10-7 │ Divine Comedy            │ Dante Alighieri  ║
        ║ 9971-5-0210-0 │ A Tale of Two Cities     │ Charles Dickens  ║
        ║ 960-425-059-0 │ The Lord of the Rings    │ J. R. R. Tolkien ║
        ║ 80-902734-1-6 │ And Then There Were None │ Agatha Christie  ║
        ╚═══════════════╧══════════════════════════╧══════════════════╝
        </code>
        *
        * @return $this
        */
        public function setHorizontalBorderChars(string $outside, ?string $inside = null): static
        {
        }
        /**
        * Sets vertical border characters.
        *
        * <code>
        ╔═══════════════╤══════════════════════════╤══════════════════╗
        ║ ISBN          │ Title                    │ Author           ║
        ╠═══════1═══════╪══════════════════════════╪══════════════════╣
        ║ 99921-58-10-7 │ Divine Comedy            │ Dante Alighieri  ║
        ║ 9971-5-0210-0 │ A Tale of Two Cities     │ Charles Dickens  ║
        ╟───────2───────┼──────────────────────────┼──────────────────╢
        ║ 960-425-059-0 │ The Lord of the Rings    │ J. R. R. Tolkien ║
        ║ 80-902734-1-6 │ And Then There Were None │ Agatha Christie  ║
        ╚═══════════════╧══════════════════════════╧══════════════════╝
        </code>
        *
        * @return $this
        */
        public function setVerticalBorderChars(string $outside, ?string $inside = null): static
        {
        }
        /**
        * Sets crossing characters.
        *
        * Example:
        <code>
        1═══════════════2══════════════════════════2══════════════════3
        ║ ISBN          │ Title                    │ Author           ║
        8'══════════════0'═════════════════════════0'═════════════════4'
        ║ 99921-58-10-7 │ Divine Comedy            │ Dante Alighieri  ║
        ║ 9971-5-0210-0 │ A Tale of Two Cities     │ Charles Dickens  ║
        8───────────────0──────────────────────────0──────────────────4
        ║ 960-425-059-0 │ The Lord of the Rings    │ J. R. R. Tolkien ║
        ║ 80-902734-1-6 │ And Then There Were None │ Agatha Christie  ║
        7═══════════════6══════════════════════════6══════════════════5
        </code>
        *
        * @param string $cross Crossing char (see #0 of example)
        * @param string $topLeft Top left char (see #1 of example)
        * @param string $topMid Top mid char (see #2 of example)
        * @param string $topRight Top right char (see #3 of example)
        * @param string $midRight Mid right char (see #4 of example)
        * @param string $bottomRight Bottom right char (see #5 of example)
        * @param string $bottomMid Bottom mid char (see #6 of example)
        * @param string $bottomLeft Bottom left char (see #7 of example)
        * @param string $midLeft Mid left char (see #8 of example)
        * @param string|null $topLeftBottom Top left bottom char (see #8' of example), equals to $midLeft if null
        * @param string|null $topMidBottom Top mid bottom char (see #0' of example), equals to $cross if null
        * @param string|null $topRightBottom Top right bottom char (see #4' of example), equals to $midRight if null
        *
        * @return $this
        */
        public function setCrossingChars(string $cross, string $topLeft, string $topMid, string $topRight, string $midRight, string $bottomRight, string $bottomMid, string $bottomLeft, string $midLeft, ?string $topLeftBottom = null, ?string $topMidBottom = null, ?string $topRightBottom = null): static
        {
        }
        /**
         * Sets default crossing character used for each cross.
         *
         * @see {@link setCrossingChars()} for setting each crossing individually.
         */
        public function setDefaultCrossingChar(string $char): self
        {
        }
        public function getCrossingChar(): string
        {
        }
        /**
         * Sets header cell format.
         *
         * @return $this
         */
        public function setCellHeaderFormat(string $cellHeaderFormat): static
        {
        }
        public function getCellHeaderFormat(): string
        {
        }
        /**
         * Sets row cell format.
         *
         * @return $this
         */
        public function setCellRowFormat(string $cellRowFormat): static
        {
        }
        public function getCellRowFormat(): string
        {
        }
        /**
         * Sets row cell content format.
         *
         * @return $this
         */
        public function setCellRowContentFormat(string $cellRowContentFormat): static
        {
        }
        public function getCellRowContentFormat(): string
        {
        }
        /**
         * Sets table border format.
         *
         * @return $this
         */
        public function setBorderFormat(string $borderFormat): static
        {
        }
        public function getBorderFormat(): string
        {
        }
        /**
         * Sets cell padding type.
         *
         * @return $this
         */
        public function setPadType(int $padType): static
        {
        }
        public function getPadType(): int
        {
        }
        public function getHeaderTitleFormat(): string
        {
        }
        /**
         * @return $this
         */
        public function setHeaderTitleFormat(string $format): static
        {
        }
        public function getFooterTitleFormat(): string
        {
        }
        /**
         * @return $this
         */
        public function setFooterTitleFormat(string $format): static
        {
        }
    }
}
namespace Symfony\Component\Console\Input {
    /**
     * Represents a command line argument.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class InputArgument
    {
        public const REQUIRED = 1;
        public const OPTIONAL = 2;
        public const IS_ARRAY = 4;
        /**
         * @param string $name The argument name
         * @param int|null $mode The argument mode: a bit mask of self::REQUIRED, self::OPTIONAL and self::IS_ARRAY
         * @param string $description A description text
         * @param string|bool|int|float|array|null $default The default value (for self::OPTIONAL mode only)
         * @param array|\Closure(\Symfony\Component\Console\Completion\CompletionInput, \Symfony\Component\Console\Completion\CompletionSuggestions): list<string|\Symfony\Component\Console\Completion\Suggestion> $suggestedValues The values used for input completion
         *
         * @throws \Symfony\Component\Console\Exception\InvalidArgumentException When argument mode is not valid
         */
        public function __construct(string $name, ?int $mode = null, string $description = '', string|bool|int|float|array|null $default = null, \Closure|array $suggestedValues = [])
        {
        }
        public function getName(): string
        {
        }
        /**
         * Returns true if the argument is required.
         *
         * @return bool true if parameter mode is self::REQUIRED, false otherwise
         */
        public function isRequired(): bool
        {
        }
        /**
         * Returns true if the argument can take multiple values.
         *
         * @return bool true if mode is self::IS_ARRAY, false otherwise
         */
        public function isArray(): bool
        {
        }
        /**
         * Sets the default value.
         *
         * @return void
         *
         * @throws \Symfony\Component\Console\Exception\LogicException When incorrect default value is given
         */
        public function setDefault(string|bool|int|float|array|null $default = null)
        {
        }
        public function getDefault(): string|bool|int|float|array|null
        {
        }
        public function hasCompletion(): bool
        {
        }
        /**
         * Adds suggestions to $suggestions for the current completion input.
         *
         * @see Command::complete()
         */
        public function complete(\Symfony\Component\Console\Completion\CompletionInput $input, \Symfony\Component\Console\Completion\CompletionSuggestions $suggestions): void
        {
        }
        public function getDescription(): string
        {
        }
    }
    /**
    * InputInterface is the interface implemented by all input classes.
    *
    * @author Fabien Potencier <fabien@symfony.com>
    *
    * @method string __toString() Returns a stringified representation of the args passed to the command.
                               InputArguments MUST be escaped as well as the InputOption values passed to the command.
    */
    interface InputInterface
    {
        public function getFirstArgument(): ?string;
        /**
        * Returns true if the raw parameters (not parsed) contain a value.
        *
        * This method is to be used to introspect the input parameters
        before they have been validated. It must be used carefully.
        Does not necessarily return the correct result for short options
        when multiple flags are combined in the same option.
        *
        * @param string|array $values The values to look for in the raw parameters (can be an array)
        * @param bool $onlyParams Only check real parameters, skip those following an end of options (--) signal
        */
        public function hasParameterOption(string|array $values, bool $onlyParams = false): bool;
        /**
        * Returns the value of a raw option (not parsed).
        *
        * This method is to be used to introspect the input parameters
        before they have been validated. It must be used carefully.
        Does not necessarily return the correct result for short options
        when multiple flags are combined in the same option.
        *
        * @param string|array $values The value(s) to look for in the raw parameters (can be an array)
        * @param string|bool|int|float|array|null $default The default value to return if no result is found
        * @param bool $onlyParams Only check real parameters, skip those following an end of options (--) signal
        *
        * @return mixed
        */
        public function getParameterOption(string|array $values, string|bool|int|float|array|null $default = false, bool $onlyParams = false);
        /**
         * Binds the current Input instance with the given arguments and options.
         *
         * @return void
         *
         * @throws \Symfony\Component\Console\Exception\RuntimeException
         */
        public function bind(\Symfony\Component\Console\Input\InputDefinition $definition);
        /**
         * Validates the input.
         *
         * @return void
         *
         * @throws \Symfony\Component\Console\Exception\RuntimeException When not enough arguments are given
         */
        public function validate();
        /**
         * Returns all the given arguments merged with the default values.
         *
         * @return array<string|bool|int|float|array|null>
         */
        public function getArguments(): array;
        /**
         * Returns the argument value for a given argument name.
         *
         * @return mixed
         *
         * @throws \Symfony\Component\Console\Exception\InvalidArgumentException When argument given doesn't exist
         */
        public function getArgument(string $name);
        /**
         * Sets an argument value by name.
         *
         * @return void
         *
         * @throws \Symfony\Component\Console\Exception\InvalidArgumentException When argument given doesn't exist
         */
        public function setArgument(string $name, mixed $value);
        public function hasArgument(string $name): bool;
        /**
         * Returns all the given options merged with the default values.
         *
         * @return array<string|bool|int|float|array|null>
         */
        public function getOptions(): array;
        /**
         * Returns the option value for a given option name.
         *
         * @return mixed
         *
         * @throws \Symfony\Component\Console\Exception\InvalidArgumentException When option given doesn't exist
         */
        public function getOption(string $name);
        /**
         * Sets an option value by name.
         *
         * @return void
         *
         * @throws \Symfony\Component\Console\Exception\InvalidArgumentException When option given doesn't exist
         */
        public function setOption(string $name, mixed $value);
        public function hasOption(string $name): bool;
        public function isInteractive(): bool;
        /**
         * Sets the input interactivity.
         *
         * @return void
         */
        public function setInteractive(bool $interactive);
    }
    /**
     * Represents a command line option.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class InputOption
    {
        public const VALUE_NONE = 1;
        public const VALUE_REQUIRED = 2;
        public const VALUE_OPTIONAL = 4;
        public const VALUE_IS_ARRAY = 8;
        public const VALUE_NEGATABLE = 16;
        /**
         * @param string|array|null $shortcut The shortcuts, can be null, a string of shortcuts delimited by | or an array of shortcuts
         * @param int|null $mode The option mode: One of the VALUE_* constants
         * @param string|bool|int|float|array|null $default The default value (must be null for self::VALUE_NONE)
         * @param array|\Closure(\Symfony\Component\Console\Completion\CompletionInput, \Symfony\Component\Console\Completion\CompletionSuggestions): list<string|\Symfony\Component\Console\Completion\Suggestion> $suggestedValues The values used for input completion
         *
         * @throws \Symfony\Component\Console\Exception\InvalidArgumentException If option mode is invalid or incompatible
         */
        public function __construct(string $name, string|array|null $shortcut = null, ?int $mode = null, string $description = '', string|bool|int|float|array|null $default = null, array|\Closure $suggestedValues = [])
        {
        }
        public function getShortcut(): ?string
        {
        }
        public function getName(): string
        {
        }
        /**
         * Returns true if the option accepts a value.
         *
         * @return bool true if value mode is not self::VALUE_NONE, false otherwise
         */
        public function acceptValue(): bool
        {
        }
        /**
         * Returns true if the option requires a value.
         *
         * @return bool true if value mode is self::VALUE_REQUIRED, false otherwise
         */
        public function isValueRequired(): bool
        {
        }
        /**
         * Returns true if the option takes an optional value.
         *
         * @return bool true if value mode is self::VALUE_OPTIONAL, false otherwise
         */
        public function isValueOptional(): bool
        {
        }
        /**
         * Returns true if the option can take multiple values.
         *
         * @return bool true if mode is self::VALUE_IS_ARRAY, false otherwise
         */
        public function isArray(): bool
        {
        }
        public function isNegatable(): bool
        {
        }
        /**
         * @return void
         */
        public function setDefault(string|bool|int|float|array|null $default = null)
        {
        }
        public function getDefault(): string|bool|int|float|array|null
        {
        }
        public function getDescription(): string
        {
        }
        public function hasCompletion(): bool
        {
        }
        /**
         * Adds suggestions to $suggestions for the current completion input.
         *
         * @see Command::complete()
         */
        public function complete(\Symfony\Component\Console\Completion\CompletionInput $input, \Symfony\Component\Console\Completion\CompletionSuggestions $suggestions): void
        {
        }
        public function equals(self $option): bool
        {
        }
    }
}
namespace Symfony\Component\Console\Output {
    /**
     * OutputInterface is the interface implemented by all Output classes.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    interface OutputInterface
    {
        public const VERBOSITY_QUIET = 16;
        public const VERBOSITY_NORMAL = 32;
        public const VERBOSITY_VERBOSE = 64;
        public const VERBOSITY_VERY_VERBOSE = 128;
        public const VERBOSITY_DEBUG = 256;
        public const OUTPUT_NORMAL = 1;
        public const OUTPUT_RAW = 2;
        public const OUTPUT_PLAIN = 4;
        /**
        * Writes a message to the output.
        *
        * @param bool $newline Whether to add a newline
        * @param int $options A bitmask of options (one of the OUTPUT or VERBOSITY constants),
                        0 is considered the same as self::OUTPUT_NORMAL | self::VERBOSITY_NORMAL
        *
        * @return void
        */
        public function write(string|iterable $messages, bool $newline = false, int $options = 0);
        /**
        * Writes a message to the output and adds a newline at the end.
        *
        * @param int $options A bitmask of options (one of the OUTPUT or VERBOSITY constants),
                       0 is considered the same as self::OUTPUT_NORMAL | self::VERBOSITY_NORMAL
        *
        * @return void
        */
        public function writeln(string|iterable $messages, int $options = 0);
        /**
         * Sets the verbosity of the output.
         *
         * @param self::VERBOSITY_* $level
         *
         * @return void
         */
        public function setVerbosity(int $level);
        /**
         * Gets the current verbosity of the output.
         *
         * @return self::VERBOSITY_*
         */
        public function getVerbosity(): int;
        public function isQuiet(): bool;
        public function isVerbose(): bool;
        public function isVeryVerbose(): bool;
        public function isDebug(): bool;
        /**
         * Sets the decorated flag.
         *
         * @return void
         */
        public function setDecorated(bool $decorated);
        public function isDecorated(): bool;
        /**
         * @return void
         */
        public function setFormatter(\Symfony\Component\Console\Formatter\OutputFormatterInterface $formatter);
        public function getFormatter(): \Symfony\Component\Console\Formatter\OutputFormatterInterface;
    }
}
namespace Symfony\Component\Console\Question {
    /**
     * Represents a Question.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class Question
    {
        /**
         * @param string $question The question to ask to the user
         * @param string|bool|int|float|null $default The default answer to return if the user enters nothing
         */
        public function __construct(string $question, string|bool|int|float|null $default = null)
        {
        }
        public function getQuestion(): string
        {
        }
        public function getDefault(): string|bool|int|float|null
        {
        }
        public function isMultiline(): bool
        {
        }
        /**
         * Sets whether the user response should accept newline characters.
         *
         * @return $this
         */
        public function setMultiline(bool $multiline): static
        {
        }
        public function isHidden(): bool
        {
        }
        /**
         * Sets whether the user response must be hidden or not.
         *
         * @return $this
         *
         * @throws \Symfony\Component\Console\Exception\LogicException In case the autocompleter is also used
         */
        public function setHidden(bool $hidden): static
        {
        }
        public function isHiddenFallback(): bool
        {
        }
        /**
         * Sets whether to fallback on non-hidden question if the response cannot be hidden.
         *
         * @return $this
         */
        public function setHiddenFallback(bool $fallback): static
        {
        }
        public function getAutocompleterValues(): ?iterable
        {
        }
        /**
         * Sets values for the autocompleter.
         *
         * @return $this
         *
         * @throws \Symfony\Component\Console\Exception\LogicException
         */
        public function setAutocompleterValues(?iterable $values): static
        {
        }
        public function getAutocompleterCallback(): ?callable
        {
        }
        /**
         * Sets the callback function used for the autocompleter.
         *
         * The callback is passed the user input as argument and should return an iterable of corresponding suggestions.
         *
         * @return $this
         */
        public function setAutocompleterCallback(?callable $callback = null): static
        {
        }
        /**
         * Sets a validator for the question.
         *
         * @return $this
         */
        public function setValidator(?callable $validator = null): static
        {
        }
        public function getValidator(): ?callable
        {
        }
        /**
         * Sets the maximum number of attempts.
         *
         * Null means an unlimited number of attempts.
         *
         * @return $this
         *
         * @throws \Symfony\Component\Console\Exception\InvalidArgumentException in case the number of attempts is invalid
         */
        public function setMaxAttempts(?int $attempts): static
        {
        }
        public function getMaxAttempts(): ?int
        {
        }
        /**
         * Sets a normalizer for the response.
         *
         * The normalizer can be a callable (a string), a closure or a class implementing __invoke.
         *
         * @return $this
         */
        public function setNormalizer(callable $normalizer): static
        {
        }
        public function getNormalizer(): ?callable
        {
        }
        /**
         * @return bool
         */
        protected function isAssoc(array $array)
        {
        }
        public function isTrimmable(): bool
        {
        }
        /**
         * @return $this
         */
        public function setTrimmable(bool $trimmable): static
        {
        }
    }
}
namespace Symfony\Component\Console\Style {
    /**
     * Output decorator helpers for the Symfony Style Guide.
     *
     * @author Kevin Bond <kevinbond@gmail.com>
     */
    class SymfonyStyle extends \Symfony\Component\Console\Style\OutputStyle
    {
        public const MAX_LINE_LENGTH = 120;
        public function __construct(\Symfony\Component\Console\Input\InputInterface $input, \Symfony\Component\Console\Output\OutputInterface $output)
        {
        }
        /**
         * Formats a message as a block of text.
         *
         * @return void
         */
        public function block(string|array $messages, ?string $type = null, ?string $style = null, string $prefix = ' ', bool $padding = false, bool $escape = true)
        {
        }
        /**
         * @return void
         */
        public function title(string $message)
        {
        }
        /**
         * @return void
         */
        public function section(string $message)
        {
        }
        /**
         * @return void
         */
        public function listing(array $elements)
        {
        }
        /**
         * @return void
         */
        public function text(string|array $message)
        {
        }
        /**
         * Formats a command comment.
         *
         * @return void
         */
        public function comment(string|array $message)
        {
        }
        /**
         * @return void
         */
        public function success(string|array $message)
        {
        }
        /**
         * @return void
         */
        public function error(string|array $message)
        {
        }
        /**
         * @return void
         */
        public function warning(string|array $message)
        {
        }
        /**
         * @return void
         */
        public function note(string|array $message)
        {
        }
        /**
         * Formats an info message.
         *
         * @return void
         */
        public function info(string|array $message)
        {
        }
        /**
         * @return void
         */
        public function caution(string|array $message)
        {
        }
        /**
         * @return void
         */
        public function table(array $headers, array $rows)
        {
        }
        /**
         * Formats a horizontal table.
         *
         * @return void
         */
        public function horizontalTable(array $headers, array $rows)
        {
        }
        /**
        * Formats a list of key/value horizontally.
        *
        * Each row can be one of:
        * 'A title'
        * ['key' => 'value']
        * new TableSeparator()
        *
        * @return void
        */
        public function definitionList(string|array|\Symfony\Component\Console\Helper\TableSeparator ...$list)
        {
        }
        public function ask(string $question, ?string $default = null, ?callable $validator = null): mixed
        {
        }
        public function askHidden(string $question, ?callable $validator = null): mixed
        {
        }
        public function confirm(string $question, bool $default = true): bool
        {
        }
        public function choice(string $question, array $choices, mixed $default = null, bool $multiSelect = false): mixed
        {
        }
        /**
         * @return void
         */
        public function progressStart(int $max = 0)
        {
        }
        /**
         * @return void
         */
        public function progressAdvance(int $step = 1)
        {
        }
        /**
         * @return void
         */
        public function progressFinish()
        {
        }
        public function createProgressBar(int $max = 0): \Symfony\Component\Console\Helper\ProgressBar
        {
        }
        /**
         * @see ProgressBar::iterate()
         *
         * @template TKey
         * @template TValue
         *
         * @param iterable<TKey, TValue> $iterable
         * @param int|null $max Number of steps to complete the bar (0 if indeterminate), if null it will be inferred from $iterable
         *
         * @return iterable<TKey, TValue>
         */
        public function progressIterate(iterable $iterable, ?int $max = null): iterable
        {
        }
        public function askQuestion(\Symfony\Component\Console\Question\Question $question): mixed
        {
        }
        /**
         * @return void
         */
        public function writeln(string|iterable $messages, int $type = self::OUTPUT_NORMAL)
        {
        }
        /**
         * @return void
         */
        public function write(string|iterable $messages, bool $newline = false, int $type = self::OUTPUT_NORMAL)
        {
        }
        /**
         * @return void
         */
        public function newLine(int $count = 1)
        {
        }
        public function getErrorStyle(): self
        {
        }
        public function createTable(): \Symfony\Component\Console\Helper\Table
        {
        }
    }
}
namespace Symfony\Contracts\EventDispatcher {
    /**
    * Event is the base class for classes containing event data.
    *
    * This class contains no event data. It is used by events that do not pass
    state information to an event handler when an event is raised.
    *
    * You can call the method stopPropagation() to abort the execution of
    further listeners in your event listener.
    *
    * @author Guilherme Blanco <guilhermeblanco@hotmail.com>
    * @author Jonathan Wage <jonwage@gmail.com>
    * @author Roman Borschel <roman@code-factory.org>
    * @author Bernhard Schussek <bschussek@gmail.com>
    * @author Nicolas Grekas <p@tchwork.com>
    */
    class Event implements \Psr\EventDispatcher\StoppableEventInterface
    {
        public function isPropagationStopped(): bool
        {
        }
        public function stopPropagation(): void
        {
        }
    }
}
namespace Symfony\Component\EventDispatcher {
    /**
    * The EventDispatcherInterface is the central point of Symfony's event listener system.
    Listeners are registered on the manager and events are dispatched through the
    manager.
    *
    * @author Bernhard Schussek <bschussek@gmail.com>
    */
    interface EventDispatcherInterface extends \Symfony\Contracts\EventDispatcher\EventDispatcherInterface
    {
        /**
        * Adds an event listener that listens on the specified events.
        *
        * @param int $priority The higher this value, the earlier an event
                        listener will be triggered in the chain (defaults to 0)
        *
        * @return void
        */
        public function addListener(string $eventName, callable $listener, int $priority = 0);
        /**
        * Adds an event subscriber.
        *
        * The subscriber is asked for all the events it is
        interested in and added as a listener for these events.
        *
        * @return void
        */
        public function addSubscriber(\Symfony\Component\EventDispatcher\EventSubscriberInterface $subscriber);
        /**
         * Removes an event listener from the specified events.
         *
         * @return void
         */
        public function removeListener(string $eventName, callable $listener);
        /**
         * @return void
         */
        public function removeSubscriber(\Symfony\Component\EventDispatcher\EventSubscriberInterface $subscriber);
        /**
         * Gets the listeners of a specific event or all listeners sorted by descending priority.
         *
         * @return array<callable[]|callable>
         */
        public function getListeners(?string $eventName = null): array;
        public function getListenerPriority(string $eventName, callable $listener): ?int;
        public function hasListeners(?string $eventName = null): bool;
    }
    /**
    * An EventSubscriber knows itself what events it is interested in.
    If an EventSubscriber is added to an EventDispatcherInterface, the manager invokes
    {@link getSubscribedEvents} and registers the subscriber as a listener for all
    returned events.
    *
    * @author Guilherme Blanco <guilhermeblanco@hotmail.com>
    * @author Jonathan Wage <jonwage@gmail.com>
    * @author Roman Borschel <roman@code-factory.org>
    * @author Bernhard Schussek <bschussek@gmail.com>
    */
    interface EventSubscriberInterface
    {
        /**
        * Returns an array of event names this subscriber wants to listen to.
        *
        * The array keys are event names and the value can be:
        *
        *  * The method name to call (priority defaults to 0)
         * An array composed of the method name to call and the priority
         * An array of arrays composed of the method names to call and respective
           priorities, or 0 if unset
        *
        * For instance:
        *
        *  * ['eventName' => 'methodName']
         * ['eventName' => ['methodName', $priority]]
         * ['eventName' => [['methodName1', $priority], ['methodName2']]]
        *
        * The code must not depend on runtime state as it will only be called at compile time.
        All logic depending on runtime state must be put into the individual methods handling the events.
        *
        * @return array<string, string|array{0: string, 1: int}|list<array{0: string, 1?: int}>>
        */
        public static function getSubscribedEvents();
    }
}
namespace Symfony\Component\Filesystem\Exception {
    /**
     * Exception interface for all exceptions thrown by the component.
     *
     * @author Romain Neutron <imprec@gmail.com>
     */
    interface ExceptionInterface extends \Throwable
    {
    }
    /**
     * Exception class thrown when a file couldn't be found.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     * @author Christian Gärtner <christiangaertner.film@googlemail.com>
     */
    class FileNotFoundException extends \Symfony\Component\Filesystem\Exception\IOException
    {
        public function __construct(?string $message = null, int $code = 0, ?\Throwable $previous = null, ?string $path = null)
        {
        }
    }
    /**
     * @author Christian Flothmann <christian.flothmann@sensiolabs.de>
     */
    class InvalidArgumentException extends \InvalidArgumentException implements \Symfony\Component\Filesystem\Exception\ExceptionInterface
    {
    }
    /**
     * Exception class thrown when a filesystem operation failure happens.
     *
     * @author Romain Neutron <imprec@gmail.com>
     * @author Christian Gärtner <christiangaertner.film@googlemail.com>
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class IOException extends \RuntimeException implements \Symfony\Component\Filesystem\Exception\IOExceptionInterface
    {
        public function __construct(string $message, int $code = 0, ?\Throwable $previous = null, ?string $path = null)
        {
        }
        public function getPath(): ?string
        {
        }
    }
    /**
     * @author Théo Fidry <theo.fidry@gmail.com>
     */
    class RuntimeException extends \RuntimeException implements \Symfony\Component\Filesystem\Exception\ExceptionInterface
    {
    }
}
namespace Symfony\Component\Filesystem {
    /**
     * Provides basic utility to manipulate the file system.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class Filesystem
    {
        /**
        * Copies a file.
        *
        * If the target file is older than the origin file, it's always overwritten.
        If the target file is newer, it is overwritten only when the
        $overwriteNewerFiles option is set to true.
        *
        * @return void
        *
        * @throws \Symfony\Component\Filesystem\Exception\FileNotFoundException When originFile doesn't exist
        * @throws \Symfony\Component\Filesystem\Exception\IOException When copy fails
        */
        public function copy(string $originFile, string $targetFile, bool $overwriteNewerFiles = false)
        {
        }
        /**
         * Creates a directory recursively.
         *
         * @return void
         *
         * @throws \Symfony\Component\Filesystem\Exception\IOException On any directory creation failure
         */
        public function mkdir(string|iterable $dirs, int $mode = 0777)
        {
        }
        public function exists(string|iterable $files): bool
        {
        }
        /**
         * Sets access and modification time of file.
         *
         * @param int|null $time The touch time as a Unix timestamp, if not supplied the current system time is used
         * @param int|null $atime The access time as a Unix timestamp, if not supplied the current system time is used
         *
         * @return void
         *
         * @throws \Symfony\Component\Filesystem\Exception\IOException When touch fails
         */
        public function touch(string|iterable $files, ?int $time = null, ?int $atime = null)
        {
        }
        /**
         * Removes files or directories.
         *
         * @return void
         *
         * @throws \Symfony\Component\Filesystem\Exception\IOException When removal fails
         */
        public function remove(string|iterable $files)
        {
        }
        /**
         * Change mode for an array of files or directories.
         *
         * @param int $mode The new mode (octal)
         * @param int $umask The mode mask (octal)
         * @param bool $recursive Whether change the mod recursively or not
         *
         * @return void
         *
         * @throws \Symfony\Component\Filesystem\Exception\IOException When the change fails
         */
        public function chmod(string|iterable $files, int $mode, int $umask = 00, bool $recursive = false)
        {
        }
        /**
         * Change the owner of an array of files or directories.
         *
         * This method always throws on Windows, as the underlying PHP function is not supported.
         *
         * @see https://www.php.net/chown
         *
         * @param string|int $user A user name or number
         * @param bool $recursive Whether change the owner recursively or not
         *
         * @return void
         *
         * @throws \Symfony\Component\Filesystem\Exception\IOException When the change fails
         */
        public function chown(string|iterable $files, string|int $user, bool $recursive = false)
        {
        }
        /**
         * Change the group of an array of files or directories.
         *
         * This method always throws on Windows, as the underlying PHP function is not supported.
         *
         * @see https://www.php.net/chgrp
         *
         * @param string|int $group A group name or number
         * @param bool $recursive Whether change the group recursively or not
         *
         * @return void
         *
         * @throws \Symfony\Component\Filesystem\Exception\IOException When the change fails
         */
        public function chgrp(string|iterable $files, string|int $group, bool $recursive = false)
        {
        }
        /**
         * Renames a file or a directory.
         *
         * @return void
         *
         * @throws \Symfony\Component\Filesystem\Exception\IOException When target file or directory already exists
         * @throws \Symfony\Component\Filesystem\Exception\IOException When origin cannot be renamed
         */
        public function rename(string $origin, string $target, bool $overwrite = false)
        {
        }
        /**
         * Creates a symbolic link or copy a directory.
         *
         * @return void
         *
         * @throws \Symfony\Component\Filesystem\Exception\IOException When symlink fails
         */
        public function symlink(string $originDir, string $targetDir, bool $copyOnWindows = false)
        {
        }
        /**
         * Creates a hard link, or several hard links to a file.
         *
         * @param string|string[] $targetFiles The target file(s)
         *
         * @return void
         *
         * @throws \Symfony\Component\Filesystem\Exception\FileNotFoundException When original file is missing or not a file
         * @throws \Symfony\Component\Filesystem\Exception\IOException When link fails, including if link already exists
         */
        public function hardlink(string $originFile, string|iterable $targetFiles)
        {
        }
        public function readlink(string $path, bool $canonicalize = false): ?string
        {
        }
        public function makePathRelative(string $endPath, string $startPath): string
        {
        }
        /**
        * Mirrors a directory to another.
        *
        * Copies files and directories from the origin directory into the target directory. By default:
        *
        *  - existing files in the target directory will be overwritten, except if they are newer (see the `override` option)
         - files in the target directory that do not exist in the source directory will not be deleted (see the `delete` option)
        *
        * @param \Traversable|null $iterator Iterator that filters which files and directories to copy, if null a recursive iterator is created
        * @param array $options An array of boolean options
                                      Valid options are:
                                      - $options['override'] If true, target files newer than origin files are overwritten (see copy(), defaults to false)
                                      - $options['copy_on_windows'] Whether to copy files instead of links on Windows (see symlink(), defaults to false)
                                      - $options['delete'] Whether to delete files that are not in the source directory (defaults to false)
        *
        * @return void
        *
        * @throws \Symfony\Component\Filesystem\Exception\IOException When file type is unknown
        */
        public function mirror(string $originDir, string $targetDir, ?\Traversable $iterator = null, array $options = [])
        {
        }
        public function isAbsolutePath(string $file): bool
        {
        }
        /**
        * Creates a temporary file with support for custom stream wrappers.
        *
        * @param string $prefix The prefix of the generated temporary filename
                         Note: Windows uses only the first three characters of prefix
        * @param string $suffix The suffix of the generated temporary filename
        *
        * @return string The new temporary filename (with path), or throw an exception on failure
        */
        public function tempnam(string $dir, string $prefix, string $suffix = ''): string
        {
        }
        /**
         * Atomically dumps content into a file.
         *
         * @param string|resource $content The data to write into the file
         *
         * @return void
         *
         * @throws \Symfony\Component\Filesystem\Exception\IOException if the file cannot be written to
         */
        public function dumpFile(string $filename, $content)
        {
        }
        /**
         * Appends content to an existing file.
         *
         * @param string|resource $content The content to append
         * @param bool $lock Whether the file should be locked when writing to it
         *
         * @return void
         *
         * @throws \Symfony\Component\Filesystem\Exception\IOException If the file is not writable
         */
        public function appendToFile(string $filename, $content)
        {
        }
    }
    /**
    * Contains utility methods for handling path strings.
    *
    * The methods in this class are able to deal with both UNIX and Windows paths
    with both forward and backward slashes. All methods return normalized parts
    containing only forward slashes and no excess "." and ".." segments.
    *
    * @author Bernhard Schussek <bschussek@gmail.com>
    * @author Thomas Schulz <mail@king2500.net>
    * @author Théo Fidry <theo.fidry@gmail.com>
    */
    final class Path
    {
        public static function canonicalize(string $path): string
        {
        }
        /**
        * Normalizes the given path.
        *
        * During normalization, all slashes are replaced by forward slashes ("/").
        Contrary to {@link canonicalize()}, this method does not remove invalid
        or dot path segments. Consequently, it is much more efficient and should
        be used whenever the given path is known to be a valid, absolute system
        path.
        *
        * This method is able to deal with both UNIX and Windows paths.
        */
        public static function normalize(string $path): string
        {
        }
        /**
        * Returns the directory part of the path.
        *
        * This method is similar to PHP's dirname(), but handles various cases
        where dirname() returns a weird result:
        *
        *  - dirname() does not accept backslashes on UNIX
         - dirname("C:/symfony") returns "C:", not "C:/"
         - dirname("C:/") returns ".", not "C:/"
         - dirname("C:") returns ".", not "C:/"
         - dirname("symfony") returns ".", not ""
         - dirname() does not canonicalize the result
        *
        * This method fixes these shortcomings and behaves like dirname()
        otherwise.
        *
        * The result is a canonical path.
        *
        * @return string The canonical directory part. Returns the root directory
                  if the root directory is passed. Returns an empty string
                  if a relative path is passed that contains no slashes.
                  Returns an empty string if an empty string is passed.
        */
        public static function getDirectory(string $path): string
        {
        }
        /**
        * Returns canonical path of the user's home directory.
        *
        * Supported operating systems:
        *
        *  - UNIX
         - Windows8 and upper
        *
        * If your operating system or environment isn't supported, an exception is thrown.
        *
        * The result is a canonical path.
        *
        * @throws \Symfony\Component\Filesystem\Exception\RuntimeException If your operating system or environment isn't supported
        */
        public static function getHomeDirectory(): string
        {
        }
        /**
        * Returns the root directory of a path.
        *
        * The result is a canonical path.
        *
        * @return string The canonical root directory. Returns an empty string if
                  the given path is relative or empty.
        */
        public static function getRoot(string $path): string
        {
        }
        /**
        * Returns the file name without the extension from a file path.
        *
        * @param string|null $extension if specified, only that extension is cut
                                 off (may contain leading dot)
        */
        public static function getFilenameWithoutExtension(string $path, ?string $extension = null): string
        {
        }
        /**
         * Returns the extension from a file path (without leading dot).
         *
         * @param bool $forceLowerCase forces the extension to be lower-case
         */
        public static function getExtension(string $path, bool $forceLowerCase = false): string
        {
        }
        /**
        * Returns whether the path has an (or the specified) extension.
        *
        * @param string $path the path string
        * @param string|string[]|null $extensions if null or not provided, checks if
                                           an extension exists, otherwise
                                           checks for the specified extension
                                           or array of extensions (with or
                                           without leading dot)
        * @param bool $ignoreCase whether to ignore case-sensitivity
        */
        public static function hasExtension(string $path, $extensions = null, bool $ignoreCase = false): bool
        {
        }
        /**
         * Changes the extension of a path string.
         *
         * @param string $path The path string with filename.ext to change.
         * @param string $extension new extension (with or without leading dot)
         *
         * @return string the path string with new file extension
         */
        public static function changeExtension(string $path, string $extension): string
        {
        }
        public static function isAbsolute(string $path): bool
        {
        }
        public static function isRelative(string $path): bool
        {
        }
        /**
        * Turns a relative path into an absolute path in canonical form.
        *
        * Usually, the relative path is appended to the given base path. Dot
        segments ("." and "..") are removed/collapsed and all slashes turned
        into forward slashes.
        *
        * ```php
        echo Path::makeAbsolute("../style.css", "/symfony/puli/css");
        // => /symfony/puli/style.css
        ```
        *
        * If an absolute path is passed, that path is returned unless its root
        directory is different than the one of the base path. In that case, an
        exception is thrown.
        *
        * ```php
        Path::makeAbsolute("/style.css", "/symfony/puli/css");
        // => /style.css
        *
        * Path::makeAbsolute("C:/style.css", "C:/symfony/puli/css");
        // => C:/style.css
        *
        * Path::makeAbsolute("C:/style.css", "/symfony/puli/css");
        // InvalidArgumentException
        ```
        *
        * If the base path is not an absolute path, an exception is thrown.
        *
        * The result is a canonical path.
        *
        * @param string $basePath an absolute base path
        *
        * @throws \Symfony\Component\Filesystem\Exception\InvalidArgumentException if the base path is not absolute or if
                                    the given path is an absolute path with
                                    a different root than the base path
        */
        public static function makeAbsolute(string $path, string $basePath): string
        {
        }
        /**
        * Turns a path into a relative path.
        *
        * The relative path is created relative to the given base path:
        *
        * ```php
        echo Path::makeRelative("/symfony/style.css", "/symfony/puli");
        // => ../style.css
        ```
        *
        * If a relative path is passed and the base path is absolute, the relative
        path is returned unchanged:
        *
        * ```php
        Path::makeRelative("style.css", "/symfony/puli/css");
        // => style.css
        ```
        *
        * If both paths are relative, the relative path is created with the
        assumption that both paths are relative to the same directory:
        *
        * ```php
        Path::makeRelative("style.css", "symfony/puli/css");
        // => ../../../style.css
        ```
        *
        * If both paths are absolute, their root directory must be the same,
        otherwise an exception is thrown:
        *
        * ```php
        Path::makeRelative("C:/symfony/style.css", "/symfony/puli");
        // InvalidArgumentException
        ```
        *
        * If the passed path is absolute, but the base path is not, an exception
        is thrown as well:
        *
        * ```php
        Path::makeRelative("/symfony/style.css", "symfony/puli");
        // InvalidArgumentException
        ```
        *
        * If the base path is not an absolute path, an exception is thrown.
        *
        * The result is a canonical path.
        *
        * @throws \Symfony\Component\Filesystem\Exception\InvalidArgumentException if the base path is not absolute or if
                                    the given path has a different root
                                    than the base path
        */
        public static function makeRelative(string $path, string $basePath): string
        {
        }
        public static function isLocal(string $path): bool
        {
        }
        public static function getLongestCommonBasePath(string ...$paths): ?string
        {
        }
        public static function join(string ...$paths): string
        {
        }
        public static function isBasePath(string $basePath, string $ofPath): bool
        {
        }
    }
}
namespace Symfony\Component\Finder\Exception {
    /**
     * @author Andreas Erhard <andreas.erhard@i-med.ac.at>
     */
    class DirectoryNotFoundException extends \InvalidArgumentException
    {
    }
}
namespace Symfony\Component\Finder {
    /**
     * Finder allows to build rules to find files and directories.
     *
     * It is a thin wrapper around several specialized iterator classes.
     *
     * All rules may be invoked several times.
     *
     * All methods return the current Finder object to allow chaining:
     *
     *     $finder = Finder::create()->files()->name('*.php')->in(__DIR__);
     *
     * @author Fabien Potencier <fabien@symfony.com>
     *
     * @implements \IteratorAggregate<string, \Symfony\Component\Finder\SplFileInfo>
     */
    class Finder implements \IteratorAggregate, \Countable
    {
        public const IGNORE_VCS_FILES = 1;
        public const IGNORE_DOT_FILES = 2;
        public const IGNORE_VCS_IGNORED_FILES = 4;
        public function __construct()
        {
        }
        public static function create(): static
        {
        }
        /**
         * Restricts the matching to directories only.
         *
         * @return $this
         */
        public function directories(): static
        {
        }
        /**
         * Restricts the matching to files only.
         *
         * @return $this
         */
        public function files(): static
        {
        }
        /**
        * Adds tests for the directory depth.
        *
        * Usage:
        *
        *     $finder->depth('> 1') // the Finder will start matching at level 1.
            $finder->depth('< 3') // the Finder will descend at most 3 levels of directories below the starting point.
            $finder->depth(['>= 1', '< 3'])
        *
        * @param string|int|string[]|int[] $levels The depth level expression or an array of depth levels
        *
        * @return $this
        *
        * @see DepthRangeFilterIterator
        * @see NumberComparator
        */
        public function depth(string|int|array $levels): static
        {
        }
        /**
        * Adds tests for file dates (last modified).
        *
        * The date must be something that strtotime() is able to parse:
        *
        *     $finder->date('since yesterday');
            $finder->date('until 2 days ago');
            $finder->date('> now - 2 hours');
            $finder->date('>= 2005-10-15');
            $finder->date(['>= 2005-10-15', '<= 2006-05-27']);
        *
        * @param string|string[] $dates A date range string or an array of date ranges
        *
        * @return $this
        *
        * @see strtotime
        * @see DateRangeFilterIterator
        * @see DateComparator
        */
        public function date(string|array $dates): static
        {
        }
        /**
        * Adds rules that files must match.
        *
        * You can use patterns (delimited with / sign), globs or simple strings.
        *
        *     $finder->name('/\.php$/')
            $finder->name('*.php') // same as above, without dot files
            $finder->name('test.php')
            $finder->name(['test.py', 'test.php'])
        *
        * @param string|string[] $patterns A pattern (a regexp, a glob, or a string) or an array of patterns
        *
        * @return $this
        *
        * @see FilenameFilterIterator
        */
        public function name(string|array $patterns): static
        {
        }
        /**
         * Adds rules that files must not match.
         *
         * @param string|string[] $patterns A pattern (a regexp, a glob, or a string) or an array of patterns
         *
         * @return $this
         *
         * @see FilenameFilterIterator
         */
        public function notName(string|array $patterns): static
        {
        }
        /**
        * Adds tests that file contents must match.
        *
        * Strings or PCRE patterns can be used:
        *
        *     $finder->contains('Lorem ipsum')
            $finder->contains('/Lorem ipsum/i')
            $finder->contains(['dolor', '/ipsum/i'])
        *
        * @param string|string[] $patterns A pattern (string or regexp) or an array of patterns
        *
        * @return $this
        *
        * @see FilecontentFilterIterator
        */
        public function contains(string|array $patterns): static
        {
        }
        /**
        * Adds tests that file contents must not match.
        *
        * Strings or PCRE patterns can be used:
        *
        *     $finder->notContains('Lorem ipsum')
            $finder->notContains('/Lorem ipsum/i')
            $finder->notContains(['lorem', '/dolor/i'])
        *
        * @param string|string[] $patterns A pattern (string or regexp) or an array of patterns
        *
        * @return $this
        *
        * @see FilecontentFilterIterator
        */
        public function notContains(string|array $patterns): static
        {
        }
        /**
        * Adds rules that filenames must match.
        *
        * You can use patterns (delimited with / sign) or simple strings.
        *
        *     $finder->path('some/special/dir')
            $finder->path('/some\/special\/dir/') // same as above
            $finder->path(['some dir', 'another/dir'])
        *
        * Use only / as dirname separator.
        *
        * @param string|string[] $patterns A pattern (a regexp or a string) or an array of patterns
        *
        * @return $this
        *
        * @see FilenameFilterIterator
        */
        public function path(string|array $patterns): static
        {
        }
        /**
        * Adds rules that filenames must not match.
        *
        * You can use patterns (delimited with / sign) or simple strings.
        *
        *     $finder->notPath('some/special/dir')
            $finder->notPath('/some\/special\/dir/') // same as above
            $finder->notPath(['some/file.txt', 'another/file.log'])
        *
        * Use only / as dirname separator.
        *
        * @param string|string[] $patterns A pattern (a regexp or a string) or an array of patterns
        *
        * @return $this
        *
        * @see FilenameFilterIterator
        */
        public function notPath(string|array $patterns): static
        {
        }
        /**
        * Adds tests for file sizes.
        *
        *     $finder->size('> 10K');
            $finder->size('<= 1Ki');
            $finder->size(4);
            $finder->size(['> 10K', '< 20K'])
        *
        * @param string|int|string[]|int[] $sizes A size range string or an integer or an array of size ranges
        *
        * @return $this
        *
        * @see SizeRangeFilterIterator
        * @see NumberComparator
        */
        public function size(string|int|array $sizes): static
        {
        }
        /**
         * Excludes directories.
         *
         * Directories passed as argument must be relative to the ones defined with the `in()` method. For example:
         *
         *     $finder->in(__DIR__)->exclude('ruby');
         *
         * @param string|array $dirs A directory path or an array of directories
         *
         * @return $this
         *
         * @see ExcludeDirectoryFilterIterator
         */
        public function exclude(string|array $dirs): static
        {
        }
        /**
         * Excludes "hidden" directories and files (starting with a dot).
         *
         * This option is enabled by default.
         *
         * @return $this
         *
         * @see ExcludeDirectoryFilterIterator
         */
        public function ignoreDotFiles(bool $ignoreDotFiles): static
        {
        }
        /**
         * Forces the finder to ignore version control directories.
         *
         * This option is enabled by default.
         *
         * @return $this
         *
         * @see ExcludeDirectoryFilterIterator
         */
        public function ignoreVCS(bool $ignoreVCS): static
        {
        }
        /**
         * Forces Finder to obey .gitignore and ignore files based on rules listed there.
         *
         * This option is disabled by default.
         *
         * @return $this
         */
        public function ignoreVCSIgnored(bool $ignoreVCSIgnored): static
        {
        }
        /**
         * Adds VCS patterns.
         *
         * @see ignoreVCS()
         *
         * @param string|string[] $pattern VCS patterns to ignore
         *
         * @return void
         */
        public static function addVCSPattern(string|array $pattern)
        {
        }
        /**
         * Sorts files and directories by an anonymous function.
         *
         * The anonymous function receives two \SplFileInfo instances to compare.
         *
         * This can be slow as all the matching files and directories must be retrieved for comparison.
         *
         * @return $this
         *
         * @see SortableIterator
         */
        public function sort(\Closure $closure): static
        {
        }
        /**
         * Sorts files and directories by extension.
         *
         * This can be slow as all the matching files and directories must be retrieved for comparison.
         *
         * @return $this
         *
         * @see SortableIterator
         */
        public function sortByExtension(): static
        {
        }
        /**
         * Sorts files and directories by name.
         *
         * This can be slow as all the matching files and directories must be retrieved for comparison.
         *
         * @return $this
         *
         * @see SortableIterator
         */
        public function sortByName(bool $useNaturalSort = false): static
        {
        }
        /**
         * Sorts files and directories by name case insensitive.
         *
         * This can be slow as all the matching files and directories must be retrieved for comparison.
         *
         * @return $this
         *
         * @see SortableIterator
         */
        public function sortByCaseInsensitiveName(bool $useNaturalSort = false): static
        {
        }
        /**
         * Sorts files and directories by size.
         *
         * This can be slow as all the matching files and directories must be retrieved for comparison.
         *
         * @return $this
         *
         * @see SortableIterator
         */
        public function sortBySize(): static
        {
        }
        /**
         * Sorts files and directories by type (directories before files), then by name.
         *
         * This can be slow as all the matching files and directories must be retrieved for comparison.
         *
         * @return $this
         *
         * @see SortableIterator
         */
        public function sortByType(): static
        {
        }
        /**
         * Sorts files and directories by the last accessed time.
         *
         * This is the time that the file was last accessed, read or written to.
         *
         * This can be slow as all the matching files and directories must be retrieved for comparison.
         *
         * @return $this
         *
         * @see SortableIterator
         */
        public function sortByAccessedTime(): static
        {
        }
        /**
         * Reverses the sorting.
         *
         * @return $this
         */
        public function reverseSorting(): static
        {
        }
        /**
         * Sorts files and directories by the last inode changed time.
         *
         * This is the time that the inode information was last modified (permissions, owner, group or other metadata).
         *
         * On Windows, since inode is not available, changed time is actually the file creation time.
         *
         * This can be slow as all the matching files and directories must be retrieved for comparison.
         *
         * @return $this
         *
         * @see SortableIterator
         */
        public function sortByChangedTime(): static
        {
        }
        /**
         * Sorts files and directories by the last modified time.
         *
         * This is the last time the actual contents of the file were last modified.
         *
         * This can be slow as all the matching files and directories must be retrieved for comparison.
         *
         * @return $this
         *
         * @see SortableIterator
         */
        public function sortByModifiedTime(): static
        {
        }
        /**
        * Filters the iterator with an anonymous function.
        *
        * The anonymous function receives a \SplFileInfo and must return false
        to remove files.
        *
        * @param \Closure(\Symfony\Component\Finder\SplFileInfo): bool $closure
        * @param bool $prune Whether to skip traversing directories further
        *
        * @return $this
        *
        * @see CustomFilterIterator
        */
        public function filter(\Closure $closure): static
        {
        }
        /**
         * Forces the following of symlinks.
         *
         * @return $this
         */
        public function followLinks(): static
        {
        }
        /**
         * Tells finder to ignore unreadable directories.
         *
         * By default, scanning unreadable directories content throws an AccessDeniedException.
         *
         * @return $this
         */
        public function ignoreUnreadableDirs(bool $ignore = true): static
        {
        }
        /**
         * Searches files and directories which match defined rules.
         *
         * @param string|string[] $dirs A directory path or an array of directories
         *
         * @return $this
         *
         * @throws \Symfony\Component\Finder\Exception\DirectoryNotFoundException if one of the directories does not exist
         */
        public function in(string|array $dirs): static
        {
        }
        /**
         * Returns an Iterator for the current Finder configuration.
         *
         * This method implements the IteratorAggregate interface.
         *
         * @return \Iterator<string, \Symfony\Component\Finder\SplFileInfo>
         *
         * @throws \LogicException if the in() method has not been called
         */
        public function getIterator(): \Iterator
        {
        }
        /**
         * Appends an existing set of files/directories to the finder.
         *
         * The set can be another Finder, an Iterator, an IteratorAggregate, or even a plain array.
         *
         * @return $this
         *
         * @throws \InvalidArgumentException when the given argument is not iterable
         */
        public function append(iterable $iterator): static
        {
        }
        public function hasResults(): bool
        {
        }
        public function count(): int
        {
        }
    }
    /**
     * Extends \SplFileInfo to support relative paths.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     */
    class SplFileInfo extends \SplFileInfo
    {
        /**
         * @param string $file The file name
         * @param string $relativePath The relative path
         * @param string $relativePathname The relative path name
         */
        public function __construct(string $file, string $relativePath, string $relativePathname)
        {
        }
        public function getRelativePath(): string
        {
        }
        public function getRelativePathname(): string
        {
        }
        public function getFilenameWithoutExtension(): string
        {
        }
        /**
         * Returns the contents of the file.
         *
         * @throws \RuntimeException
         */
        public function getContents(): string
        {
        }
    }
}
namespace Symfony\Component\Process\Exception {
    /**
     * Marker Interface for the Process Component.
     *
     * @author Johannes M. Schmitt <schmittjoh@gmail.com>
     */
    interface ExceptionInterface extends \Throwable
    {
    }
    /**
     * LogicException for the Process Component.
     *
     * @author Romain Neutron <imprec@gmail.com>
     */
    class LogicException extends \LogicException implements \Symfony\Component\Process\Exception\ExceptionInterface
    {
    }
    /**
     * Exception for failed processes.
     *
     * @author Johannes M. Schmitt <schmittjoh@gmail.com>
     */
    class ProcessFailedException extends \Symfony\Component\Process\Exception\RuntimeException
    {
        public function __construct(\Symfony\Component\Process\Process $process)
        {
        }
        /**
         * @return \Symfony\Component\Process\Process
         */
        public function getProcess()
        {
        }
    }
    /**
     * Exception that is thrown when a process has been signaled.
     *
     * @author Sullivan Senechal <soullivaneuh@gmail.com>
     */
    final class ProcessSignaledException extends \Symfony\Component\Process\Exception\RuntimeException
    {
        public function __construct(\Symfony\Component\Process\Process $process)
        {
        }
        public function getProcess(): \Symfony\Component\Process\Process
        {
        }
        public function getSignal(): int
        {
        }
    }
    /**
     * Exception that is thrown when a process times out.
     *
     * @author Johannes M. Schmitt <schmittjoh@gmail.com>
     */
    class ProcessTimedOutException extends \Symfony\Component\Process\Exception\RuntimeException
    {
        public const TYPE_GENERAL = 1;
        public const TYPE_IDLE = 2;
        public function __construct(\Symfony\Component\Process\Process $process, int $timeoutType)
        {
        }
        /**
         * @return \Symfony\Component\Process\Process
         */
        public function getProcess()
        {
        }
        /**
         * @return bool
         */
        public function isGeneralTimeout()
        {
        }
        /**
         * @return bool
         */
        public function isIdleTimeout()
        {
        }
        public function getExceededTimeout(): ?float
        {
        }
    }
    /**
     * RuntimeException for the Process Component.
     *
     * @author Johannes M. Schmitt <schmittjoh@gmail.com>
     */
    class RuntimeException extends \RuntimeException implements \Symfony\Component\Process\Exception\ExceptionInterface
    {
    }
}
namespace Symfony\Component\Process {
    /**
     * Generic executable finder.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     * @author Johannes M. Schmitt <schmittjoh@gmail.com>
     */
    class ExecutableFinder
    {
        /**
         * Replaces default suffixes of executable.
         *
         * @return void
         */
        public function setSuffixes(array $suffixes)
        {
        }
        /**
         * Adds new possible suffix to check for executable.
         *
         * @return void
         */
        public function addSuffix(string $suffix)
        {
        }
        /**
         * Finds an executable by name.
         *
         * @param string $name The executable name (without the extension)
         * @param string|null $default The default to return if no executable is found
         * @param array $extraDirs Additional dirs to check into
         */
        public function find(string $name, ?string $default = null, array $extraDirs = []): ?string
        {
        }
    }
    /**
    * Process is a thin wrapper around proc_* functions to easily
    start independent PHP processes.
    *
    * @author Fabien Potencier <fabien@symfony.com>
    * @author Romain Neutron <imprec@gmail.com>
    *
    * @implements \IteratorAggregate<string, string>
    */
    class Process implements \IteratorAggregate
    {
        public const ERR = 'err';
        public const OUT = 'out';
        public const STATUS_READY = 'ready';
        public const STATUS_STARTED = 'started';
        public const STATUS_TERMINATED = 'terminated';
        public const STDIN = 0;
        public const STDOUT = 1;
        public const STDERR = 2;
        public const TIMEOUT_PRECISION = 0.2;
        public const ITER_NON_BLOCKING = 1;
        public const ITER_KEEP_OUTPUT = 2;
        public const ITER_SKIP_OUT = 4;
        public const ITER_SKIP_ERR = 8;
        public static $exitCodes = [0 => 'OK', 1 => 'General error', 2 => 'Misuse of shell builtins', 126 => 'Invoked command cannot execute', 127 => 'Command not found', 128 => 'Invalid exit argument', 129 => 'Hangup', 130 => 'Interrupt', 131 => 'Quit and dump core', 132 => 'Illegal instruction', 133 => 'Trace/breakpoint trap', 134 => 'Process aborted', 135 => 'Bus error: "access to undefined portion of memory object"', 136 => 'Floating point exception: "erroneous arithmetic operation"', 137 => 'Kill (terminate immediately)', 138 => 'User-defined 1', 139 => 'Segmentation violation', 140 => 'User-defined 2', 141 => 'Write to pipe with no one reading', 142 => 'Signal raised by alarm', 143 => 'Termination (request to terminate)', 145 => 'Child process terminated, stopped (or continued*)', 146 => 'Continue if stopped', 147 => 'Stop executing temporarily', 148 => 'Terminal stop signal', 149 => 'Background process attempting to read from tty ("in")', 150 => 'Background process attempting to write to tty ("out")', 151 => 'Urgent data available on socket', 152 => 'CPU time limit exceeded', 153 => 'File size limit exceeded', 154 => 'Signal raised by timer counting virtual time: "virtual timer expired"', 155 => 'Profiling timer expired', 157 => 'Pollable event', 159 => 'Bad syscall'];
        /**
         * @param array $command The command to run and its arguments listed as separate entries
         * @param string|null $cwd The working directory or null to use the working dir of the current PHP process
         * @param array|null $env The environment variables or null to use the same environment as the current PHP process
         * @param mixed $input The input as stream resource, scalar or \Traversable, or null for no input
         * @param int|float|null $timeout The timeout in seconds or null to disable
         *
         * @throws \Symfony\Component\Process\Exception\LogicException When proc_open is not installed
         */
        public function __construct(array $command, ?string $cwd = null, ?array $env = null, mixed $input = null, ?float $timeout = 60)
        {
        }
        /**
        * Creates a Process instance as a command-line to be run in a shell wrapper.
        *
        * Command-lines are parsed by the shell of your OS (/bin/sh on Unix-like, cmd.exe on Windows.)
        This allows using e.g. pipes or conditional execution. In this mode, signals are sent to the
        shell wrapper and not to your commands.
        *
        * In order to inject dynamic values into command-lines, we strongly recommend using placeholders.
        This will save escaping values, which is not portable nor secure anyway:
        *
        *   $process = Process::fromShellCommandline('my_command "${:MY_VAR}"');
          $process->run(null, ['MY_VAR' => $theValue]);
        *
        * @param string $command The command line to pass to the shell of the OS
        * @param string|null $cwd The working directory or null to use the working dir of the current PHP process
        * @param array|null $env The environment variables or null to use the same environment as the current PHP process
        * @param mixed $input The input as stream resource, scalar or \Traversable, or null for no input
        * @param int|float|null $timeout The timeout in seconds or null to disable
        *
        * @throws \Symfony\Component\Process\Exception\LogicException When proc_open is not installed
        */
        public static function fromShellCommandline(string $command, ?string $cwd = null, ?array $env = null, mixed $input = null, ?float $timeout = 60): static
        {
        }
        public function __sleep(): array
        {
        }
        /**
         * @return void
         */
        public function __wakeup()
        {
        }
        public function __destruct()
        {
        }
        public function __clone()
        {
        }
        /**
        * Runs the process.
        *
        * The callback receives the type of output (out or err) and
        some bytes from the output in real-time. It allows to have feedback
        from the independent process during execution.
        *
        * The STDOUT and STDERR are also available after the process is finished
        via the getOutput() and getErrorOutput() methods.
        *
        * @param callable|null $callback A PHP callback to run whenever there is some
                                  output available on STDOUT or STDERR
        *
        * @return int The exit status code
        *
        * @throws \Symfony\Component\Process\Exception\RuntimeException When process can't be launched
        * @throws \Symfony\Component\Process\Exception\RuntimeException When process is already running
        * @throws \Symfony\Component\Process\Exception\ProcessTimedOutException When process timed out
        * @throws \Symfony\Component\Process\Exception\ProcessSignaledException When process stopped after receiving signal
        * @throws \Symfony\Component\Process\Exception\LogicException In case a callback is provided and output has been disabled
        *
        * @final
        */
        public function run(?callable $callback = null, array $env = []): int
        {
        }
        /**
        * Runs the process.
        *
        * This is identical to run() except that an exception is thrown if the process
        exits with a non-zero exit code.
        *
        * @return $this
        *
        * @throws \Symfony\Component\Process\Exception\ProcessFailedException if the process didn't terminate successfully
        *
        * @final
        */
        public function mustRun(?callable $callback = null, array $env = []): static
        {
        }
        /**
        * Starts the process and returns after writing the input to STDIN.
        *
        * This method blocks until all STDIN data is sent to the process then it
        returns while the process runs in the background.
        *
        * The termination of the process can be awaited with wait().
        *
        * The callback receives the type of output (out or err) and some bytes from
        the output in real-time while writing the standard input to the process.
        It allows to have feedback from the independent process during execution.
        *
        * @param callable|null $callback A PHP callback to run whenever there is some
                                  output available on STDOUT or STDERR
        *
        * @return void
        *
        * @throws \Symfony\Component\Process\Exception\RuntimeException When process can't be launched
        * @throws \Symfony\Component\Process\Exception\RuntimeException When process is already running
        * @throws \Symfony\Component\Process\Exception\LogicException In case a callback is provided and output has been disabled
        */
        public function start(?callable $callback = null, array $env = [])
        {
        }
        /**
        * Restarts the process.
        *
        * Be warned that the process is cloned before being started.
        *
        * @param callable|null $callback A PHP callback to run whenever there is some
                                  output available on STDOUT or STDERR
        *
        * @throws \Symfony\Component\Process\Exception\RuntimeException When process can't be launched
        * @throws \Symfony\Component\Process\Exception\RuntimeException When process is already running
        *
        * @see start()
        *
        * @final
        */
        public function restart(?callable $callback = null, array $env = []): static
        {
        }
        /**
        * Waits for the process to terminate.
        *
        * The callback receives the type of output (out or err) and some bytes
        from the output in real-time while writing the standard input to the process.
        It allows to have feedback from the independent process during execution.
        *
        * @param callable|null $callback A valid PHP callback
        *
        * @return int The exitcode of the process
        *
        * @throws \Symfony\Component\Process\Exception\ProcessTimedOutException When process timed out
        * @throws \Symfony\Component\Process\Exception\ProcessSignaledException When process stopped after receiving signal
        * @throws \Symfony\Component\Process\Exception\LogicException When process is not yet started
        */
        public function wait(?callable $callback = null): int
        {
        }
        /**
        * Waits until the callback returns true.
        *
        * The callback receives the type of output (out or err) and some bytes
        from the output in real-time while writing the standard input to the process.
        It allows to have feedback from the independent process during execution.
        *
        * @throws \Symfony\Component\Process\Exception\RuntimeException When process timed out
        * @throws \Symfony\Component\Process\Exception\LogicException When process is not yet started
        * @throws \Symfony\Component\Process\Exception\ProcessTimedOutException In case the timeout was reached
        */
        public function waitUntil(callable $callback): bool
        {
        }
        /**
         * Returns the Pid (process identifier), if applicable.
         *
         * @return int|null The process id if running, null otherwise
         */
        public function getPid(): ?int
        {
        }
        /**
         * Sends a POSIX signal to the process.
         *
         * @param int $signal A valid POSIX signal (see https://php.net/pcntl.constants)
         *
         * @return $this
         *
         * @throws \Symfony\Component\Process\Exception\LogicException In case the process is not running
         * @throws \Symfony\Component\Process\Exception\RuntimeException In case --enable-sigchild is activated and the process can't be killed
         * @throws \Symfony\Component\Process\Exception\RuntimeException In case of failure
         */
        public function signal(int $signal): static
        {
        }
        /**
         * Disables fetching output and error output from the underlying process.
         *
         * @return $this
         *
         * @throws \Symfony\Component\Process\Exception\RuntimeException In case the process is already running
         * @throws \Symfony\Component\Process\Exception\LogicException if an idle timeout is set
         */
        public function disableOutput(): static
        {
        }
        /**
         * Enables fetching output and error output from the underlying process.
         *
         * @return $this
         *
         * @throws \Symfony\Component\Process\Exception\RuntimeException In case the process is already running
         */
        public function enableOutput(): static
        {
        }
        public function isOutputDisabled(): bool
        {
        }
        /**
         * Returns the current output of the process (STDOUT).
         *
         * @throws \Symfony\Component\Process\Exception\LogicException in case the output has been disabled
         * @throws \Symfony\Component\Process\Exception\LogicException In case the process is not started
         */
        public function getOutput(): string
        {
        }
        /**
        * Returns the output incrementally.
        *
        * In comparison with the getOutput method which always return the whole
        output, this one returns the new output since the last call.
        *
        * @throws \Symfony\Component\Process\Exception\LogicException in case the output has been disabled
        * @throws \Symfony\Component\Process\Exception\LogicException In case the process is not started
        */
        public function getIncrementalOutput(): string
        {
        }
        /**
         * Returns an iterator to the output of the process, with the output type as keys (Process::OUT/ERR).
         *
         * @param int $flags A bit field of Process::ITER_* flags
         *
         * @return \Generator<string, string>
         *
         * @throws \Symfony\Component\Process\Exception\LogicException in case the output has been disabled
         * @throws \Symfony\Component\Process\Exception\LogicException In case the process is not started
         */
        public function getIterator(int $flags = 0): \Generator
        {
        }
        /**
         * Clears the process output.
         *
         * @return $this
         */
        public function clearOutput(): static
        {
        }
        /**
         * Returns the current error output of the process (STDERR).
         *
         * @throws \Symfony\Component\Process\Exception\LogicException in case the output has been disabled
         * @throws \Symfony\Component\Process\Exception\LogicException In case the process is not started
         */
        public function getErrorOutput(): string
        {
        }
        /**
        * Returns the errorOutput incrementally.
        *
        * In comparison with the getErrorOutput method which always return the
        whole error output, this one returns the new error output since the last
        call.
        *
        * @throws \Symfony\Component\Process\Exception\LogicException in case the output has been disabled
        * @throws \Symfony\Component\Process\Exception\LogicException In case the process is not started
        */
        public function getIncrementalErrorOutput(): string
        {
        }
        /**
         * Clears the process output.
         *
         * @return $this
         */
        public function clearErrorOutput(): static
        {
        }
        /**
         * Returns the exit code returned by the process.
         *
         * @return int|null The exit status code, null if the Process is not terminated
         */
        public function getExitCode(): ?int
        {
        }
        /**
        * Returns a string representation for the exit code returned by the process.
        *
        * This method relies on the Unix exit code status standardization
        and might not be relevant for other operating systems.
        *
        * @return string|null A string representation for the exit status code, null if the Process is not terminated
        *
        * @see http://tldp.org/LDP/abs/html/exitcodes.html
        * @see http://en.wikipedia.org/wiki/Unix_signal
        */
        public function getExitCodeText(): ?string
        {
        }
        public function isSuccessful(): bool
        {
        }
        /**
         * Returns true if the child process has been terminated by an uncaught signal.
         *
         * It always returns false on Windows.
         *
         * @throws \Symfony\Component\Process\Exception\LogicException In case the process is not terminated
         */
        public function hasBeenSignaled(): bool
        {
        }
        /**
         * Returns the number of the signal that caused the child process to terminate its execution.
         *
         * It is only meaningful if hasBeenSignaled() returns true.
         *
         * @throws \Symfony\Component\Process\Exception\RuntimeException In case --enable-sigchild is activated
         * @throws \Symfony\Component\Process\Exception\LogicException In case the process is not terminated
         */
        public function getTermSignal(): int
        {
        }
        /**
         * Returns true if the child process has been stopped by a signal.
         *
         * It always returns false on Windows.
         *
         * @throws \Symfony\Component\Process\Exception\LogicException In case the process is not terminated
         */
        public function hasBeenStopped(): bool
        {
        }
        /**
         * Returns the number of the signal that caused the child process to stop its execution.
         *
         * It is only meaningful if hasBeenStopped() returns true.
         *
         * @throws \Symfony\Component\Process\Exception\LogicException In case the process is not terminated
         */
        public function getStopSignal(): int
        {
        }
        public function isRunning(): bool
        {
        }
        public function isStarted(): bool
        {
        }
        public function isTerminated(): bool
        {
        }
        public function getStatus(): string
        {
        }
        /**
         * Stops the process.
         *
         * @param int|float $timeout The timeout in seconds
         * @param int|null $signal A POSIX signal to send in case the process has not stop at timeout, default is SIGKILL (9)
         *
         * @return int|null The exit-code of the process or null if it's not running
         */
        public function stop(float $timeout = 10, ?int $signal = null): ?int
        {
        }
        public function getLastOutputTime(): ?float
        {
        }
        public function getCommandLine(): string
        {
        }
        public function getTimeout(): ?float
        {
        }
        public function getIdleTimeout(): ?float
        {
        }
        /**
         * Sets the process timeout (max. runtime) in seconds.
         *
         * To disable the timeout, set this value to null.
         *
         * @return $this
         *
         * @throws \Symfony\Component\Process\Exception\InvalidArgumentException if the timeout is negative
         */
        public function setTimeout(?float $timeout): static
        {
        }
        /**
         * Sets the process idle timeout (max. time since last output) in seconds.
         *
         * To disable the timeout, set this value to null.
         *
         * @return $this
         *
         * @throws \Symfony\Component\Process\Exception\LogicException if the output is disabled
         * @throws \Symfony\Component\Process\Exception\InvalidArgumentException if the timeout is negative
         */
        public function setIdleTimeout(?float $timeout): static
        {
        }
        /**
         * Enables or disables the TTY mode.
         *
         * @return $this
         *
         * @throws \Symfony\Component\Process\Exception\RuntimeException In case the TTY mode is not supported
         */
        public function setTty(bool $tty): static
        {
        }
        public function isTty(): bool
        {
        }
        /**
         * Sets PTY mode.
         *
         * @return $this
         */
        public function setPty(bool $bool): static
        {
        }
        public function isPty(): bool
        {
        }
        public function getWorkingDirectory(): ?string
        {
        }
        /**
         * Sets the current working directory.
         *
         * @return $this
         */
        public function setWorkingDirectory(string $cwd): static
        {
        }
        public function getEnv(): array
        {
        }
        /**
         * Sets the environment variables.
         *
         * @param array<string|\Stringable> $env The new environment variables
         *
         * @return $this
         */
        public function setEnv(array $env): static
        {
        }
        /**
         * Gets the Process input.
         *
         * @return resource|string|\Iterator|null
         */
        public function getInput()
        {
        }
        /**
         * Sets the input.
         *
         * This content will be passed to the underlying process standard input.
         *
         * @param string|resource|\Traversable|self|null $input The content
         *
         * @return $this
         *
         * @throws \Symfony\Component\Process\Exception\LogicException In case the process is running
         */
        public function setInput(mixed $input): static
        {
        }
        /**
        * Performs a check between the timeout definition and the time the process started.
        *
        * In case you run a background process (with the start method), you should
        trigger this method regularly to ensure the process timeout
        *
        * @return void
        *
        * @throws \Symfony\Component\Process\Exception\ProcessTimedOutException In case the timeout was reached
        */
        public function checkTimeout()
        {
        }
        /**
         * @throws \Symfony\Component\Process\Exception\LogicException in case process is not started
         */
        public function getStartTime(): float
        {
        }
        /**
        * Defines options to pass to the underlying proc_open().
        *
        * @see https://php.net/proc_open for the options supported by PHP.
        *
        * Enabling the "create_new_console" option allows a subprocess to continue
        to run after the main process exited, on both Windows and *nix
        *
        * @return void
        */
        public function setOptions(array $options)
        {
        }
        public static function isTtySupported(): bool
        {
        }
        public static function isPtySupported(): bool
        {
        }
        /**
        * Builds up the callback used by wait().
        *
        * The callbacks adds all occurred output to the specific buffer and calls
        the user callback (if present) with the received output.
        *
        * @param callable|null $callback The user defined PHP callback
        */
        protected function buildCallback(?callable $callback = null): \Closure
        {
        }
        /**
         * Updates the status of the process, reads pipes.
         *
         * @param bool $blocking Whether to use a blocking read call
         *
         * @return void
         */
        protected function updateStatus(bool $blocking)
        {
        }
        protected function isSigchildEnabled(): bool
        {
        }
    }
}
namespace Symfony\Component\String {
    /**
    * Represents a string of abstract characters.
    *
    * Unicode defines 3 types of "characters" (bytes, code points and grapheme clusters).
    This class is the abstract type to use as a type-hint when the logic you want to
    implement doesn't care about the exact variant it deals with.
    *
    * @author Nicolas Grekas <p@tchwork.com>
    * @author Hugo Hamon <hugohamon@neuf.fr>
    *
    * @throws \Symfony\Component\String\Exception\ExceptionInterface
    */
    abstract class AbstractString implements \Stringable, \JsonSerializable
    {
        public const PREG_PATTERN_ORDER = \PREG_PATTERN_ORDER;
        public const PREG_SET_ORDER = \PREG_SET_ORDER;
        public const PREG_OFFSET_CAPTURE = \PREG_OFFSET_CAPTURE;
        public const PREG_UNMATCHED_AS_NULL = \PREG_UNMATCHED_AS_NULL;
        public const PREG_SPLIT = 0;
        public const PREG_SPLIT_NO_EMPTY = \PREG_SPLIT_NO_EMPTY;
        public const PREG_SPLIT_DELIM_CAPTURE = \PREG_SPLIT_DELIM_CAPTURE;
        public const PREG_SPLIT_OFFSET_CAPTURE = \PREG_SPLIT_OFFSET_CAPTURE;
        protected $string = '';
        protected $ignoreCase = false;
        abstract public function __construct(string $string = '');
        /**
         * Unwraps instances of AbstractString back to strings.
         *
         * @return string[]|array
         */
        public static function unwrap(array $values): array
        {
        }
        /**
         * Wraps (and normalizes) strings in instances of AbstractString.
         *
         * @return static[]|array
         */
        public static function wrap(array $values): array
        {
        }
        /**
         * @param string|string[] $needle
         */
        public function after(string|iterable $needle, bool $includeNeedle = false, int $offset = 0): static
        {
        }
        /**
         * @param string|string[] $needle
         */
        public function afterLast(string|iterable $needle, bool $includeNeedle = false, int $offset = 0): static
        {
        }
        abstract public function append(string ...$suffix): static;
        /**
         * @param string|string[] $needle
         */
        public function before(string|iterable $needle, bool $includeNeedle = false, int $offset = 0): static
        {
        }
        /**
         * @param string|string[] $needle
         */
        public function beforeLast(string|iterable $needle, bool $includeNeedle = false, int $offset = 0): static
        {
        }
        /**
         * @return int[]
         */
        public function bytesAt(int $offset): array
        {
        }
        abstract public function camel(): static;
        /**
         * @return static[]
         */
        abstract public function chunk(int $length = 1): array;
        public function collapseWhitespace(): static
        {
        }
        /**
         * @param string|string[] $needle
         */
        public function containsAny(string|iterable $needle): bool
        {
        }
        /**
         * @param string|string[] $suffix
         */
        public function endsWith(string|iterable $suffix): bool
        {
        }
        public function ensureEnd(string $suffix): static
        {
        }
        public function ensureStart(string $prefix): static
        {
        }
        /**
         * @param string|string[] $string
         */
        public function equalsTo(string|iterable $string): bool
        {
        }
        abstract public function folded(): static;
        public function ignoreCase(): static
        {
        }
        /**
         * @param string|string[] $needle
         */
        public function indexOf(string|iterable $needle, int $offset = 0): ?int
        {
        }
        /**
         * @param string|string[] $needle
         */
        public function indexOfLast(string|iterable $needle, int $offset = 0): ?int
        {
        }
        public function isEmpty(): bool
        {
        }
        abstract public function join(array $strings, ?string $lastGlue = null): static;
        public function jsonSerialize(): string
        {
        }
        abstract public function length(): int;
        abstract public function lower(): static;
        /**
         * Matches the string using a regular expression.
         *
         * Pass PREG_PATTERN_ORDER or PREG_SET_ORDER as $flags to get all occurrences matching the regular expression.
         *
         * @return array All matches in a multi-dimensional array ordered according to flags
         */
        abstract public function match(string $regexp, int $flags = 0, int $offset = 0): array;
        abstract public function padBoth(int $length, string $padStr = ' '): static;
        abstract public function padEnd(int $length, string $padStr = ' '): static;
        abstract public function padStart(int $length, string $padStr = ' '): static;
        abstract public function prepend(string ...$prefix): static;
        public function repeat(int $multiplier): static
        {
        }
        abstract public function replace(string $from, string $to): static;
        abstract public function replaceMatches(string $fromRegexp, string|callable $to): static;
        abstract public function reverse(): static;
        abstract public function slice(int $start = 0, ?int $length = null): static;
        abstract public function snake(): static;
        abstract public function splice(string $replacement, int $start = 0, ?int $length = null): static;
        /**
         * @return static[]
         */
        public function split(string $delimiter, ?int $limit = null, ?int $flags = null): array
        {
        }
        /**
         * @param string|string[] $prefix
         */
        public function startsWith(string|iterable $prefix): bool
        {
        }
        abstract public function title(bool $allWords = false): static;
        public function toByteString(?string $toEncoding = null): \Symfony\Component\String\ByteString
        {
        }
        public function toCodePointString(): \Symfony\Component\String\CodePointString
        {
        }
        public function toString(): string
        {
        }
        public function toUnicodeString(): \Symfony\Component\String\UnicodeString
        {
        }
        abstract public function trim(string $chars = " \t\n\r\x00\v\f ﻿"): static;
        abstract public function trimEnd(string $chars = " \t\n\r\x00\v\f ﻿"): static;
        /**
         * @param string|string[] $prefix
         */
        public function trimPrefix($prefix): static
        {
        }
        abstract public function trimStart(string $chars = " \t\n\r\x00\v\f ﻿"): static;
        /**
         * @param string|string[] $suffix
         */
        public function trimSuffix($suffix): static
        {
        }
        public function truncate(int $length, string $ellipsis = '', bool $cut = true): static
        {
        }
        abstract public function upper(): static;
        abstract public function width(bool $ignoreAnsiDecoration = true): int;
        public function wordwrap(int $width = 75, string $break = "\n", bool $cut = false): static
        {
        }
        public function __sleep(): array
        {
        }
        public function __clone()
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
    * Represents a string of abstract Unicode characters.
    *
    * Unicode defines 3 types of "characters" (bytes, code points and grapheme clusters).
    This class is the abstract type to use as a type-hint when the logic you want to
    implement is Unicode-aware but doesn't care about code points vs grapheme clusters.
    *
    * @author Nicolas Grekas <p@tchwork.com>
    *
    * @throws \Symfony\Component\String\Exception\ExceptionInterface
    */
    abstract class AbstractUnicodeString extends \Symfony\Component\String\AbstractString
    {
        public const NFC = \Normalizer::NFC;
        public const NFD = \Normalizer::NFD;
        public const NFKC = \Normalizer::NFKC;
        public const NFKD = \Normalizer::NFKD;
        public static function fromCodePoints(int ...$codes): static
        {
        }
        /**
         * Generic UTF-8 to ASCII transliteration.
         *
         * Install the intl extension for best results.
         *
         * @param string[]|\Transliterator[]|\Closure[] $rules See "*-Latin" rules from Transliterator::listIDs()
         */
        public function ascii(array $rules = []): self
        {
        }
        public function camel(): static
        {
        }
        /**
         * @return int[]
         */
        public function codePointsAt(int $offset): array
        {
        }
        public function folded(bool $compat = true): static
        {
        }
        public function join(array $strings, ?string $lastGlue = null): static
        {
        }
        public function lower(): static
        {
        }
        public function match(string $regexp, int $flags = 0, int $offset = 0): array
        {
        }
        public function normalize(int $form = self::NFC): static
        {
        }
        public function padBoth(int $length, string $padStr = ' '): static
        {
        }
        public function padEnd(int $length, string $padStr = ' '): static
        {
        }
        public function padStart(int $length, string $padStr = ' '): static
        {
        }
        public function replaceMatches(string $fromRegexp, string|callable $to): static
        {
        }
        public function reverse(): static
        {
        }
        public function snake(): static
        {
        }
        public function title(bool $allWords = false): static
        {
        }
        public function trim(string $chars = " \t\n\r\x00\v\f ﻿"): static
        {
        }
        public function trimEnd(string $chars = " \t\n\r\x00\v\f ﻿"): static
        {
        }
        public function trimPrefix($prefix): static
        {
        }
        public function trimStart(string $chars = " \t\n\r\x00\v\f ﻿"): static
        {
        }
        public function trimSuffix($suffix): static
        {
        }
        public function upper(): static
        {
        }
        public function width(bool $ignoreAnsiDecoration = true): int
        {
        }
    }
    /**
     * Represents a binary-safe string of bytes.
     *
     * @author Nicolas Grekas <p@tchwork.com>
     * @author Hugo Hamon <hugohamon@neuf.fr>
     *
     * @throws \Symfony\Component\String\Exception\ExceptionInterface
     */
    class ByteString extends \Symfony\Component\String\AbstractString
    {
        public function __construct(string $string = '')
        {
        }
        public static function fromRandom(int $length = 16, ?string $alphabet = null): self
        {
        }
        public function bytesAt(int $offset): array
        {
        }
        public function append(string ...$suffix): static
        {
        }
        public function camel(): static
        {
        }
        public function chunk(int $length = 1): array
        {
        }
        public function endsWith(string|iterable|\Symfony\Component\String\AbstractString $suffix): bool
        {
        }
        public function equalsTo(string|iterable|\Symfony\Component\String\AbstractString $string): bool
        {
        }
        public function folded(): static
        {
        }
        public function indexOf(string|iterable|\Symfony\Component\String\AbstractString $needle, int $offset = 0): ?int
        {
        }
        public function indexOfLast(string|iterable|\Symfony\Component\String\AbstractString $needle, int $offset = 0): ?int
        {
        }
        public function isUtf8(): bool
        {
        }
        public function join(array $strings, ?string $lastGlue = null): static
        {
        }
        public function length(): int
        {
        }
        public function lower(): static
        {
        }
        public function match(string $regexp, int $flags = 0, int $offset = 0): array
        {
        }
        public function padBoth(int $length, string $padStr = ' '): static
        {
        }
        public function padEnd(int $length, string $padStr = ' '): static
        {
        }
        public function padStart(int $length, string $padStr = ' '): static
        {
        }
        public function prepend(string ...$prefix): static
        {
        }
        public function replace(string $from, string $to): static
        {
        }
        public function replaceMatches(string $fromRegexp, string|callable $to): static
        {
        }
        public function reverse(): static
        {
        }
        public function slice(int $start = 0, ?int $length = null): static
        {
        }
        public function snake(): static
        {
        }
        public function splice(string $replacement, int $start = 0, ?int $length = null): static
        {
        }
        public function split(string $delimiter, ?int $limit = null, ?int $flags = null): array
        {
        }
        public function startsWith(string|iterable|\Symfony\Component\String\AbstractString $prefix): bool
        {
        }
        public function title(bool $allWords = false): static
        {
        }
        public function toUnicodeString(?string $fromEncoding = null): \Symfony\Component\String\UnicodeString
        {
        }
        public function toCodePointString(?string $fromEncoding = null): \Symfony\Component\String\CodePointString
        {
        }
        public function trim(string $chars = " \t\n\r\x00\v\f"): static
        {
        }
        public function trimEnd(string $chars = " \t\n\r\x00\v\f"): static
        {
        }
        public function trimStart(string $chars = " \t\n\r\x00\v\f"): static
        {
        }
        public function upper(): static
        {
        }
        public function width(bool $ignoreAnsiDecoration = true): int
        {
        }
    }
    /**
     * Represents a string of Unicode code points encoded as UTF-8.
     *
     * @author Nicolas Grekas <p@tchwork.com>
     * @author Hugo Hamon <hugohamon@neuf.fr>
     *
     * @throws \Symfony\Component\String\Exception\ExceptionInterface
     */
    class CodePointString extends \Symfony\Component\String\AbstractUnicodeString
    {
        public function __construct(string $string = '')
        {
        }
        public function append(string ...$suffix): static
        {
        }
        public function chunk(int $length = 1): array
        {
        }
        public function codePointsAt(int $offset): array
        {
        }
        public function endsWith(string|iterable|\Symfony\Component\String\AbstractString $suffix): bool
        {
        }
        public function equalsTo(string|iterable|\Symfony\Component\String\AbstractString $string): bool
        {
        }
        public function indexOf(string|iterable|\Symfony\Component\String\AbstractString $needle, int $offset = 0): ?int
        {
        }
        public function indexOfLast(string|iterable|\Symfony\Component\String\AbstractString $needle, int $offset = 0): ?int
        {
        }
        public function length(): int
        {
        }
        public function prepend(string ...$prefix): static
        {
        }
        public function replace(string $from, string $to): static
        {
        }
        public function slice(int $start = 0, ?int $length = null): static
        {
        }
        public function splice(string $replacement, int $start = 0, ?int $length = null): static
        {
        }
        public function split(string $delimiter, ?int $limit = null, ?int $flags = null): array
        {
        }
        public function startsWith(string|iterable|\Symfony\Component\String\AbstractString $prefix): bool
        {
        }
    }
    /**
    * Represents a string of Unicode grapheme clusters encoded as UTF-8.
    *
    * A letter followed by combining characters (accents typically) form what Unicode defines
    as a grapheme cluster: a character as humans mean it in written texts. This class knows
    about the concept and won't split a letter apart from its combining accents. It also
    ensures all string comparisons happen on their canonically-composed representation,
    ignoring e.g. the order in which accents are listed when a letter has many of them.
    *
    * @see https://unicode.org/reports/tr15/
    *
    * @author Nicolas Grekas <p@tchwork.com>
    * @author Hugo Hamon <hugohamon@neuf.fr>
    *
    * @throws \Symfony\Component\String\Exception\ExceptionInterface
    */
    class UnicodeString extends \Symfony\Component\String\AbstractUnicodeString
    {
        public function __construct(string $string = '')
        {
        }
        public function append(string ...$suffix): static
        {
        }
        public function chunk(int $length = 1): array
        {
        }
        public function endsWith(string|iterable|\Symfony\Component\String\AbstractString $suffix): bool
        {
        }
        public function equalsTo(string|iterable|\Symfony\Component\String\AbstractString $string): bool
        {
        }
        public function indexOf(string|iterable|\Symfony\Component\String\AbstractString $needle, int $offset = 0): ?int
        {
        }
        public function indexOfLast(string|iterable|\Symfony\Component\String\AbstractString $needle, int $offset = 0): ?int
        {
        }
        public function join(array $strings, ?string $lastGlue = null): static
        {
        }
        public function length(): int
        {
        }
        public function normalize(int $form = self::NFC): static
        {
        }
        public function prepend(string ...$prefix): static
        {
        }
        public function replace(string $from, string $to): static
        {
        }
        public function replaceMatches(string $fromRegexp, string|callable $to): static
        {
        }
        public function slice(int $start = 0, ?int $length = null): static
        {
        }
        public function splice(string $replacement, int $start = 0, ?int $length = null): static
        {
        }
        public function split(string $delimiter, ?int $limit = null, ?int $flags = null): array
        {
        }
        public function startsWith(string|iterable|\Symfony\Component\String\AbstractString $prefix): bool
        {
        }
        /**
         * @return void
         */
        public function __wakeup()
        {
        }
        public function __clone()
        {
        }
    }
    if (!\function_exists(\Symfony\Component\String\u::class)) {
        function u(?string $string = ''): \Symfony\Component\String\UnicodeString
        {
        }
    }
    if (!\function_exists(\Symfony\Component\String\b::class)) {
        function b(?string $string = ''): \Symfony\Component\String\ByteString
        {
        }
    }
    if (!\function_exists(\Symfony\Component\String\s::class)) {
        /**
         * @return \Symfony\Component\String\UnicodeString|\Symfony\Component\String\ByteString
         */
        function s(?string $string = ''): \Symfony\Component\String\AbstractString
        {
        }
    }
}
namespace Symfony\Component\String\Exception {
    interface ExceptionInterface extends \Throwable
    {
    }
}
namespace Symfony\Contracts\Cache {
    /**
     * Covers most simple to advanced caching needs.
     *
     * @author Nicolas Grekas <p@tchwork.com>
     */
    interface CacheInterface
    {
        /**
        * Fetches a value from the pool or computes it if not found.
        *
        * On cache misses, a callback is called that should return the missing value.
        This callback is given a PSR-6 CacheItemInterface instance corresponding to the
        requested key, that could be used e.g. for expiration control. It could also
        be an ItemInterface instance when its additional features are needed.
        *
        * @template T
        *
        * @param string $key The key of the item to retrieve from the cache
        * @param callable(\Psr\Cache\CacheItemInterface, bool): T|callable(\Symfony\Contracts\Cache\ItemInterface, bool): T|\Symfony\Contracts\Cache\CallbackInterface<T> $callback
        * @param float|null $beta A float that, as it grows, controls the likeliness of triggering
                                early expiration. 0 disables it, INF forces immediate expiration.
                                The default (or providing null) is implementation dependent but should
                                typically be 1.0, which should provide optimal stampede protection.
                                See https://en.wikipedia.org/wiki/Cache_stampede#Probabilistic_early_expiration
        * @param array &$metadata The metadata of the cached item {@see ItemInterface::getMetadata()}
        *
        * @return T
        *
        * @throws \Psr\Cache\InvalidArgumentException When $key is not valid or when $beta is negative
        */
        public function get(string $key, callable $callback, ?float $beta = null, ?array &$metadata = null): mixed;
        /**
         * Removes an item from the pool.
         *
         * @param string $key The key to delete
         *
         * @return bool True if the item was successfully removed, false if there was any error
         *
         * @throws \Psr\Cache\InvalidArgumentException When $key is not valid
         */
        public function delete(string $key): bool;
    }
    /**
     * Computes and returns the cached value of an item.
     *
     * @author Nicolas Grekas <p@tchwork.com>
     *
     * @template T
     */
    interface CallbackInterface
    {
        /**
         * @param \Psr\Cache\CacheItemInterface|\Symfony\Contracts\Cache\ItemInterface $item The item to compute the value for
         * @param bool &$save Should be set to false when the value should not be saved in the pool
         *
         * @return T The computed value for the passed item
         */
        public function __invoke(\Psr\Cache\CacheItemInterface $item, bool &$save): mixed;
    }
    /**
     * Augments PSR-6's CacheItemInterface with support for tags and metadata.
     *
     * @author Nicolas Grekas <p@tchwork.com>
     */
    interface ItemInterface extends \Psr\Cache\CacheItemInterface
    {
        public const METADATA_EXPIRY = 'expiry';
        public const METADATA_CTIME = 'ctime';
        public const METADATA_TAGS = 'tags';
        public const RESERVED_CHARACTERS = '{}()/\@:';
        /**
         * Adds a tag to a cache item.
         *
         * Tags are strings that follow the same validation rules as keys.
         *
         * @param string|string[] $tags A tag or array of tags
         *
         * @return $this
         *
         * @throws \Psr\Cache\InvalidArgumentException When $tag is not valid
         * @throws \Psr\Cache\CacheException When the item comes from a pool that is not tag-aware
         */
        public function tag(string|iterable $tags): static;
        public function getMetadata(): array;
    }
}
namespace Symfony\Contracts\HttpClient\Exception {
    /**
     * When a 4xx response is returned.
     *
     * @author Nicolas Grekas <p@tchwork.com>
     */
    interface ClientExceptionInterface extends \Symfony\Contracts\HttpClient\Exception\HttpExceptionInterface
    {
    }
    /**
     * The base interface for all exceptions in the contract.
     *
     * @author Nicolas Grekas <p@tchwork.com>
     */
    interface ExceptionInterface extends \Throwable
    {
    }
    /**
     * When a 3xx response is returned and the "max_redirects" option has been reached.
     *
     * @author Nicolas Grekas <p@tchwork.com>
     */
    interface RedirectionExceptionInterface extends \Symfony\Contracts\HttpClient\Exception\HttpExceptionInterface
    {
    }
    /**
     * When a 5xx response is returned.
     *
     * @author Nicolas Grekas <p@tchwork.com>
     */
    interface ServerExceptionInterface extends \Symfony\Contracts\HttpClient\Exception\HttpExceptionInterface
    {
    }
    /**
     * When any error happens at the transport level.
     *
     * @author Nicolas Grekas <p@tchwork.com>
     */
    interface TransportExceptionInterface extends \Symfony\Contracts\HttpClient\Exception\ExceptionInterface
    {
    }
}
namespace Symfony\Contracts\HttpClient {
    /**
     * Provides flexible methods for requesting HTTP resources synchronously or asynchronously.
     *
     * @see HttpClientTestCase for a reference test suite
     *
     * @author Nicolas Grekas <p@tchwork.com>
     */
    interface HttpClientInterface
    {
        public const OPTIONS_DEFAULTS = ['auth_basic' => null, 'auth_bearer' => null, 'query' => [], 'headers' => [], 'body' => '', 'json' => null, 'user_data' => null, 'max_redirects' => 20, 'http_version' => null, 'base_uri' => null, 'buffer' => true, 'on_progress' => null, 'resolve' => [], 'proxy' => null, 'no_proxy' => null, 'timeout' => null, 'max_duration' => 0, 'bindto' => '0', 'verify_peer' => true, 'verify_host' => true, 'cafile' => null, 'capath' => null, 'local_cert' => null, 'local_pk' => null, 'passphrase' => null, 'ciphers' => null, 'peer_fingerprint' => null, 'capture_peer_cert_chain' => false, 'crypto_method' => \STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT, 'extra' => []];
        /**
        * Requests an HTTP resource.
        *
        * Responses MUST be lazy, but their status code MUST be
        checked even if none of their public methods are called.
        *
        * Implementations are not required to support all options described above; they can also
        support more custom options; but in any case, they MUST throw a TransportExceptionInterface
        when an unsupported option is passed.
        *
        * @throws \Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface When an unsupported option is passed
        */
        public function request(string $method, string $url, array $options = []): \Symfony\Contracts\HttpClient\ResponseInterface;
        /**
         * Yields responses chunk by chunk as they complete.
         *
         * @param \Symfony\Contracts\HttpClient\ResponseInterface|iterable<array-key, \Symfony\Contracts\HttpClient\ResponseInterface> $responses One or more responses created by the current HTTP client
         * @param float|null $timeout The idle timeout before yielding timeout chunks
         */
        public function stream(\Symfony\Contracts\HttpClient\ResponseInterface|iterable $responses, ?float $timeout = null): \Symfony\Contracts\HttpClient\ResponseStreamInterface;
        public function withOptions(array $options): static;
    }
    /**
     * A (lazily retrieved) HTTP response.
     *
     * @author Nicolas Grekas <p@tchwork.com>
     */
    interface ResponseInterface
    {
        /**
         * Gets the HTTP status code of the response.
         *
         * @throws \Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface when a network error occurs
         */
        public function getStatusCode(): int;
        /**
         * Gets the HTTP headers of the response.
         *
         * @param bool $throw Whether an exception should be thrown on 3/4/5xx status codes
         *
         * @return string[][] The headers of the response keyed by header names in lowercase
         *
         * @throws \Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface When a network error occurs
         * @throws \Symfony\Contracts\HttpClient\Exception\RedirectionExceptionInterface On a 3xx when $throw is true and the "max_redirects" option has been reached
         * @throws \Symfony\Contracts\HttpClient\Exception\ClientExceptionInterface On a 4xx when $throw is true
         * @throws \Symfony\Contracts\HttpClient\Exception\ServerExceptionInterface On a 5xx when $throw is true
         */
        public function getHeaders(bool $throw = true): array;
        /**
         * Gets the response body as a string.
         *
         * @param bool $throw Whether an exception should be thrown on 3/4/5xx status codes
         *
         * @throws \Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface When a network error occurs
         * @throws \Symfony\Contracts\HttpClient\Exception\RedirectionExceptionInterface On a 3xx when $throw is true and the "max_redirects" option has been reached
         * @throws \Symfony\Contracts\HttpClient\Exception\ClientExceptionInterface On a 4xx when $throw is true
         * @throws \Symfony\Contracts\HttpClient\Exception\ServerExceptionInterface On a 5xx when $throw is true
         */
        public function getContent(bool $throw = true): string;
        /**
         * Gets the response body decoded as array, typically from a JSON payload.
         *
         * @param bool $throw Whether an exception should be thrown on 3/4/5xx status codes
         *
         * @throws \Symfony\Contracts\HttpClient\Exception\DecodingExceptionInterface When the body cannot be decoded to an array
         * @throws \Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface When a network error occurs
         * @throws \Symfony\Contracts\HttpClient\Exception\RedirectionExceptionInterface On a 3xx when $throw is true and the "max_redirects" option has been reached
         * @throws \Symfony\Contracts\HttpClient\Exception\ClientExceptionInterface On a 4xx when $throw is true
         * @throws \Symfony\Contracts\HttpClient\Exception\ServerExceptionInterface On a 5xx when $throw is true
         */
        public function toArray(bool $throw = true): array;
        public function cancel(): void;
        /**
        * Returns info coming from the transport layer.
        *
        * This method SHOULD NOT throw any ExceptionInterface and SHOULD be non-blocking.
        The returned info is "live": it can be empty and can change from one call to
        another, as the request/response progresses.
        *
        * The following info MUST be returned:
         - canceled (bool) - true if the response was canceled using ResponseInterface::cancel(), false otherwise
         - error (string|null) - the error message when the transfer was aborted, null otherwise
         - http_code (int) - the last response code or 0 when it is not known yet
         - http_method (string) - the HTTP verb of the last request
         - redirect_count (int) - the number of redirects followed while executing the request
         - redirect_url (string|null) - the resolved location of redirect responses, null otherwise
         - response_headers (array) - an array modelled after the special $http_response_header variable
         - start_time (float) - the time when the request was sent or 0.0 when it's pending
         - url (string) - the last effective URL of the request
         - user_data (mixed) - the value of the "user_data" request option, null if not set
        *
        * When the "capture_peer_cert_chain" option is true, the "peer_certificate_chain"
        attribute SHOULD list the peer certificates as an array of OpenSSL X.509 resources.
        *
        * Other info SHOULD be named after curl_getinfo()'s associative return value.
        *
        * @return mixed An array of all available info, or one of them when $type is
                 provided, or null when an unsupported type is requested
        */
        public function getInfo(?string $type = null): mixed;
    }
    /**
     * Yields response chunks, returned by HttpClientInterface::stream().
     *
     * @author Nicolas Grekas <p@tchwork.com>
     *
     * @extends \Iterator<\Symfony\Contracts\HttpClient\ResponseInterface, \Symfony\Contracts\HttpClient\ChunkInterface>
     */
    interface ResponseStreamInterface extends \Iterator
    {
        public function key(): \Symfony\Contracts\HttpClient\ResponseInterface;
        public function current(): \Symfony\Contracts\HttpClient\ChunkInterface;
    }
}
namespace {
    if (!\function_exists('dump')) {
        /**
         * @author Nicolas Grekas <p@tchwork.com>
         * @author Alexandre Daubois <alex.daubois@gmail.com>
         */
        function dump(mixed ...$vars): mixed
        {
        }
    }
    if (!\function_exists('dd')) {
        function dd(mixed ...$vars): never
        {
        }
    }
}
